\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small\ttfamily}}{}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}

\usepackage{pgf, tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows}


\newcommand{\Blue}[1]{\color{blue}#1\color{black}\xspace}


\usepackage{array}
% This is needed because raggedright in table elements redefines \\:
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\let\PBS=\PreserveBackslash

%%%%%%%%%%%%%% 
\newcommand{\solution}[1] {}
%\newcommand{\solution}[1] {\textbf{Solutions:}\\ #1}

%\newcommand{\comment}[1]{}
\newcommand{\comment}[1]{\marginpar{#1}}


\begin{document}

\setlength{\parskip}{2pt} 

\newcommand{\examtime}{14:00, March 14th, 2013}
\newcommand{\points}[1]{\marginpar{\bf #1 points}}
\noindent
\begin{tabular}{lr}
CHALMERS TEKNISKA H\"OGSKOLA &\examtime{}.\\
Dept. of Computer Science and Engineering & Programming Paradigms\\
Jean-Philippe Bernardy                 & DAT121 / DIT331(GU) \\
\end{tabular}

\vspace{2.5cm} \noindent
\begin{center} {\LARGE
Exam in Programming Paradigms}
\end{center}

\vspace{1.5cm}

\noindent
\examtime{}.\\
\begin{tabular}{ll}
\textbf{Examiner:} & Jean-Philippe Bernardy
\end{tabular}
\vspace{1cm}

\noindent
Permitted aids: Pen and paper. 
% English-Swedish or English-other language dictionary.

There are 6 questions: each worth 10 points. The total sum is 60
points.  

Some questions come with \emph{remarks}: you must take those
into account.  Some questions come with \emph{hints}: you may ignore
those.

You will be asked to write programs in various paradigms. Choose the
language appropriately in each case, and indicate which you choose at
the beginning of your answer.

\begin{tabular}[p]{cc}
  Paradigm & Acceptable language \\ \hline
  Imperative   & C or (an OO language where you refrain to use Objects) \\
  Object oriented & C++ or Java \\
  Functional & Haskell, ML \\
  Concurrent & Erlang, Concurrent-Haskell \\
  Logic & Prolog, Curry 
\end{tabular}

You may also use pseudo-code ressembling an actual language in the
relevant list. In that case, make sure your code can only be
interpreted in the way you intent (the responsibility lies with
you). In particular, in the case of functional/logic languages,
omitting parentheses is NOT acceptable: \texttt{a b c} is not
acceptable pseudo-code for \texttt{a (b c)}.

  
\textbf{Chalmers:}
24 points is required to pass (grade 3), 36 points is required for
grade 4, and 48 points is required for grade 5. 

\textbf{GU:}
24 points is required to pass (grade G) and 42 points is
required for grade VG.

\section{Calls and recursion}

Consider the following function, which solves the Hanoi tower problem.

\begin{minted}{c}
void Hanoi(int n,int s,int i,int d) {
  if (n>0) {
    Hanoi(n-1,s,d,i);
    move(s,d);
    Hanoi(n-1,i,s,d);
  }
}
\end{minted}

Solve the following two exercises independently.
\begin{enumerate}
\item Replace the last recursive call by a while loop (tail-call
  elimination). Remark: do not use a stack. (4 points)
\item Assume a stack; with the usual push, top and top
  functions. Transform the original Hanoi function by making the calls
  explicit. Remark: use gotos, and stack to tranform each recursive
  call. Remark: Transform the original Hanoi function, not the one
  obtained in the previous exercise.
\end{enumerate}


\newpage
\section{Objects as records}

Consider the following C++ code, which is an encoding of a class
hierarchy.
\begin{minted}{c}
struct C {
   float x;
   float y;
};

struct B {
   void *m(B*, B*);
   int f;
   void *n(B*, C*);
   int g;
};

struct A {
   void *m(A*, B*);
   int f;
};

void B_n(B* p, C* q) {
  q->x += p->f;
  q->y += p->g;
}

void B_m (B* p, B* q) {
  q->f += p->f;
  q->g += p->g;
}

void A_m(A* p, B* q) {
  q->f += p->f;
}
\end{minted}

Write the original class hierarchy in a C++-like or Java-like language.

Quick refresher:
\begin{itemize}
\item If \texttt{A} is a type, then \texttt{A*} is the type of
  pointers to \texttt{A}.
\item \texttt{void *f(A,B,...)} stands for a pointer to a function
  \texttt{f} taking arguments \texttt{A},\texttt{B},...
\item \texttt{p->f} is used to access a field \texttt{f} in a
  structure pointed by \texttt{p}.
\end{itemize}
\newpage
\section{Pattern matching Higher-Order Abstractions}

Assume the following Haskell data types:
\begin{minted}{haskell}
data List = Nil | Cons Int List
\end{minted}
and consider the following code:
\begin{minted}
map f Nil = Nil
map f (Cons x xs) = Cons (f x) (map f xs)

append Nil xs = xs
append (Cons x xs) = Cons x (append xs)

reverse Nil = Nil
reverse (Cons x xs) = append (reverse xs) (Cons x Nil)
\end{minted}


Express the each of the functions (map, append and reverse) in terms of the
higher-order function provided below.  Remark: you may \emph{not} use
recursion directly in your solution.

\begin{minted}
fold k f [] = k
fold k f (x:xs) = f x (fold k f xs)
\end{minted}

\section{Closures}
Consider the following pattern in Java:

\begin{minted}
interface Listener {
  bool respond(); 
}

class MyPrintAction implements Listener -- "Function representation"
   String text -- "environment"
   respond() {
     print(text);
   }

class Button {
  void onPress (Listener l) {
    
  }
  
} 
 
button.onPress(new MyPrintAction("Hello there"));

\end{minted}

Assuming that the interface \texttt{???} represents a closure, how
could this pattern be implemented naturally in a language with native
support for higher-order functions?

Demonstrate your answer as follows:
\begin{enumerate}
\item Tranlate the type of the onPress action
\item Translate the MyPrintAction class
\item Translate the example call to onPress 
\end{enumerate}

\section{Continuations}

Consider the following function, which computes the fibbonaci number
of its argument.
\begin{minted}
fib 0 = return 1
fib n = do x1 <- fib (n-1)
           yield
           x2 <- fib (n-2)
           return (x1 + x2)
\end{minted}

The above algorithm will be used on very big numbers, hence
potentially running for a long time, concurrently with other
processes. Therefore, the implementer of \texttt{fib} has decided to
insert a call to \texttt{yield}, which performs no useful
computational task, but gives the opportunity for the runtime
environment to schedule another processes. (The computation of the
fibbonaci number will be continued later.)

Transform \texttt{fib} to use explicit continuations. Remarks: 
\begin{itemize}
\item In the translation, you will use a different version of
  \texttt{yield}, which takes an explicit continuation as argument.
\item The translation of \texttt{fib} should also take an explicit
  continuation as argument.
\item Do not change the algorithm. Do not ``optimize'' it.
\end{itemize}

\newpage
\section{Variable-managing process}

Assume a language without pointers nor variables, but support for
concurrency. In particular, assume primitives for creating processes
and channels, and primitives for reading and writing to to
channels. For example C++-style:

\begin{verbatim}
Chan<A> newChan();
A readChan(Chan<A> c);
writeChan(Chan<A> c,A x);
void forkProcess(*void());
\end{verbatim}
or Haskell-style:
\begin{verbatim}
TODO
\end{verbatim}

The channels can transmit any type of information, including
references to channels. Your task is to simulate references to mutable
variables using the above primitives. This can be done be using a
process that manages the variable state.

\begin{enumerate}
\item Define the representation for a variable of type ``reference to
  Integer''. Name this type \texttt{Reference}
\item Write the code for the process that manages the variable state.
\item Write the code for primitives to read and write references.
Their type should be:
\begin{verbatim}
int readRef(Reference);
void writeRef(Reference, int);
\end{verbatim}
or Haskell-style:
\begin{verbatim}
TODO
\end{verbatim}
\end{enumerate}

\section{Relations}



\end{document}
