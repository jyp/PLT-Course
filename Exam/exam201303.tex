\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{minted}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}

\usepackage{pgf, tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows}


\newcommand{\Blue}[1]{\color{blue}#1\color{black}\xspace}


\usepackage{array}
% This is needed because raggedright in table elements redefines \\:
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\let\PBS=\PreserveBackslash

%%%%%%%%%%%%%%
\newcommand{\solution}[1] {}
%\newcommand{\solution}[1] {\textbf{Solutions:}\\ #1}

%\newcommand{\comment}[1]{}
\newcommand{\comment}[1]{\marginpar{#1}}


\begin{document}

\setlength{\parskip}{2pt}

\newcommand{\examtime}{14:00, March 14th, 2013}
\newcommand{\points}[1]{\marginpar{\bf #1 points}}
\noindent
\begin{tabular}{lr}
CHALMERS TEKNISKA H\"OGSKOLA &\examtime{}.\\
Dept. of Computer Science and Engineering & Programming Paradigms\\
Jean-Philippe Bernardy                 & DAT121 / DIT331(GU) \\
\end{tabular}

\vspace{2.5cm} \noindent
\begin{center} {\LARGE
Exam in Programming Paradigms}
\end{center}

\vspace{1.5cm}

\noindent
\examtime{}.\\
\begin{tabular}{ll}
\textbf{Examiner:} & Jean-Philippe Bernardy
\end{tabular}
\vspace{1cm}

\noindent
Permitted aids: Pen and paper.
% English-Swedish or English-other language dictionary.

There are 6 questions: each worth 10 points. The total sum is 60
points.

Some questions come with \emph{remarks}: you must take those
into account.  Some questions come with \emph{hints}: you may ignore
those.

You will be asked to write programs in various paradigms. Choose the
language appropriately in each case, and indicate which you choose at
the beginning of your answer.

\begin{tabular}[p]{cc}
  Paradigm & Acceptable language \\ \hline
  Imperative   & C or (an OO language where you refrain to use Objects) \\
  Object oriented & C++ or Java \\
  Functional & Haskell, ML \\
  Concurrent & Erlang, Concurrent-Haskell \\
  Logic & Prolog, Curry
\end{tabular}

You may also use pseudo-code resembling an actual language in the
relevant list. In that case, make sure your code can only be
interpreted in the way you intent (the responsibility lies with
you). In particular, in the case of functional/logic languages,
omitting parentheses is NOT acceptable: \texttt{a b c} is not
acceptable pseudo-code for \texttt{a (b c)}.


\textbf{Chalmers:}
24 points is required to pass (grade 3), 36 points is required for
grade 4, and 48 points is required for grade 5.

\textbf{GU:}
24 points is required to pass (grade G) and 42 points is
required for grade VG.

\section{Objects as records}

Consider the following C++ code, which is an encoding of a class
hierarchy.
\begin{minted}{c}
struct C {
   float x;
   float y;
};

struct B {
   void *f(B*, B*);
   int m;
   void *g(B*, C*);
   int n;
};

struct A {
   void *f(A*, B*);
   int m;
};

void B_g(B* p, C* q) {
  q->x += p->m;
  q->y += p->n;
}

void B_f(B* p, B* q) {
  q->m += p->m;
  q->n += p->n;
}

void A_f(A* p, B* q) {
  q->m += p->m;
}
\end{minted}

Write the original class hierarchy in a C++-like or Java-like language.

Quick refresher:
\begin{itemize}
\item If \texttt{A} is a type, then \texttt{A*} is the type of
  pointers to \texttt{A}.
\item \texttt{void *f(A,B,...)} stands for a pointer to a function
  \texttt{f} taking arguments \texttt{A},\texttt{B},...
\item \texttt{p->f} is used to access a field \texttt{f} in a
  structure pointed by \texttt{p}.
\end{itemize}
\section{Calls and recursion}

Consider the following function \texttt{hanoi},
which solves the Hanoi tower problem.

\begin{minted}{c}
void hanoi(int n,int s,int i,int d) {
  if (n>0) {
    hanoi(n-1,s,d,i);
    move(s,d);
    hanoi(n-1,i,s,d);
  }
}
\end{minted}

Solve the following two exercises independently.
\begin{enumerate}
\item Replace the last recursive call by a while loop (tail-call
  elimination). Remark: do not use a stack. (4 points)
\item Assume a stack; with the usual push, top and top
  functions. Transform the original \texttt{hanoi} function by making the calls
  explicit. Remark: use gotos, and stack to tranform each recursive
  call. Remark: Transform the original \texttt{hanoi} function, not the one
  obtained in the previous exercise.
\end{enumerate}

\section{Pattern matching Higher-Order Abstractions}

\comment{
Added second argument to append,
and changed the pattern matching to Nil/Cons lists
in definition of fold
}

Assume the following Haskell data types:
\begin{minted}{haskell}
data List = Nil | Cons Int List
\end{minted}
and consider the following code:
\begin{minted}{haskell}
map f Nil = Nil
map f (Cons x xs) = Cons (f x) (map f xs)

append Nil ys = ys
append (Cons x xs) ys = Cons x (append xs ys)

reverse Nil = Nil
reverse (Cons x xs) = append (reverse xs) (Cons x Nil)
\end{minted}

Express each of the functions above (\texttt{map}, \texttt{append} and \texttt{reverse}) in terms
of the higher-order function \texttt{fold} provided below.  Remark: you may
\emph{not} use recursion directly in your solution.

\begin{minted}{haskell}
fold k f Nil = k
fold k f (Cons x xs) = f x (fold k f xs)
\end{minted}
\section{Closures}

Consider the following partial implementation of the ``Observer''
pattern in Java:
\begin{minted}{java}
interface Observer {
  bool notify(Event e);
}

class MyPrintAction implements Observer {
   String text;

   bool notify(Event e) {
     print("Got the event:" + e);
     print(text);
     return true;
   }
}

class Button {
  List<Observer> os;

  void onPress (Observer l) {
    os.add(l);
  }
}
\end{minted}

And the example user code:

\begin{minted}{java}
button.onPress(new MyPrintAction("Button pressed."));
\end{minted}

Assuming that the interface \texttt{Observer} represents a closure, how
could this pattern be implemented naturally in a language with native
support for higher-order functions?

Demonstrate your answer by translating the pattern to Haskell as
follows:
\begin{enumerate}
\item Translate the type of the onPress to a Haskell type.
\item Translate the MyPrintAction class.
\item Translate the example call to onPress.
\end{enumerate}

\section{Variable-managing process}

Assume a language without pointers nor variables, but support for
concurrency. In particular, assume primitives for creating processes
and channels, and primitives for reading and writing to to
channels. For example C++-style:

\begin{minted}{cpp}
Chan<A> newChan();
A readChan(Chan<A> c);
void writeChan(Chan<A> c,A x);
void forkProcess(*void());
\end{minted}
or Haskell-style:
\begin{minted}{haskell}
newChan :: IO (Chan a)
readChan :: Chan a -> IO a
writeChan :: Chan a -> a -> IO ()
forkProcess :: IO () -> IO ()
\end{minted}

The channels can transmit any type of information, including
references to channels. Your task is to simulate references to mutable
variables using the above primitives. This can be done be using a
process that manages the variable state.

\begin{enumerate}
\item Define the representation for a variable of type ``reference to
  Integer''. Name this type \texttt{Reference}
\item Write the code for the process that manages the variable state.
\item Write the code for primitives to read and write references.
Their type should be:
\begin{minted}{cpp}
int readRef(Reference);
void writeRef(Reference, int);
\end{minted}
or Haskell-style:
\begin{minted}{haskell}
readRef :: Reference -> IO Int
writeRef :: Reference -> Int -> IO ()
\end{minted}
\end{enumerate}

\section{Relations}

Consider the following Haskell code:

\begin{minted}{haskell}
data List = Nil | Cons Int List
data Tree = Tip | Bin Tree Int Tree

append :: List -> List -> List
append Nil xs = xs
append (Cons x xs) ys = Cons x (append xs ys)

flatten :: Tree -> List
flatten Tip = Nil
flatten (Bin a x b) = append (flatten a) (Cons x (flatten b))
\end{minted}

Translate the above functions to relations \texttt{flatten'} and
\texttt{append'} such that:
\begin{minted}{haskell}
       append' x y z       is equivalent to      append x y == z
       flatten' x y        is equivalent to      flatten x == y
\end{minted}

\begin{enumerate}
\item Write the type of the relations \texttt{flatten'} and
  \texttt{append'}.
\item Write their code.
\end{enumerate}

Remark: you cannot use any other helper function in your answer, only
constructors and relations.

You may write your answer in Curry syntax or Prolog syntax.
\end{document}
