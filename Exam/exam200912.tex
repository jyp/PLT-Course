\documentclass{article}
\usepackage{graphicx}

\usepackage{amsmath}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{listings}
\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small\ttfamily}}{}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}

\usepackage{array}
% This is needed because raggedright in table elements redefines \\:
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\let\PBS=\PreserveBackslash

\setcounter{secnumdepth}{0}


\begin{document}
\noindent
\begin{tabular}{lr}
CHALMERS TEKNISKA H\"OGSKOLA &Tuesday 16th December, 2009.\\
Dept. of Computer Science and Engineering & Programming Paradigms\\
John Hughes                  & DAT120(CTH) / DIT330(GU) \\
\end{tabular}

\vspace{2.5cm} \noindent
\begin{center} {\LARGE
Exam in Programming Paradigms}
\end{center}

\vspace{1.5cm}

\noindent
Tuesday 16th December, 2007, EM.\\
Lecturer: John Hughes, tel 070 756 3760.
\vspace{1cm}

\noindent
Permitted aids:\\
English-Swedish or English-other language dictionary.

There are five questions, one on each paradigm, worth 12 points each
for a total of 60 points. 24 points is required to pass (grade 3), 36
points is required for grade 4, and 48 points is required for grade 5.

%\newcommand{\comment}[1]{}
\newcommand{\comment}[1]{\marginpar{#1}}

\newpage

\section{Imperative Programming [12 points]}

In this part of the exam, we use the following notation:

\begin{itemize}
\item
  \verb!* q! means: memory cell whose adress is \verb!q!. (Note that
  \verb!q! must be an address)
\item
  \verb!& a! means: address of \verb!a!. (Note that \verb!a! must be
  an l-value)
\end{itemize}

\begin{itemize}
\item Adresses and L-values\hfill{\textbf{[4 points]}}

Which of the following these expressions are l-values? Which expressions are adresses?
(\verb!a!, \verb!b! denote rational
numbers variables; \verb!p!, \verb!q! denote addresses of rational
numbers.)

Reproduce the following table and replace the question marks with
``yes'' or ``no'' appropriately.

\begin{center}
\begin{tabular}{>{\PBS\raggedright\hspace{0pt}}p{0.15\columnwidth}>{\PBS\raggedright\hspace{0pt}}p{0.19\columnwidth}>{\PBS\raggedright\hspace{0pt}}p{0.10\columnwidth}}
expression
 & l-value
 & address
\\
\hline
a
 & ?
 & ?
\\
p
 & ?
 & ?
\\
a + 1
 & ?
 & ?
\\
\& a
 & ?
 & ?
\\
\& p
 & ?
 & ?
\\
* p
 & ?
 & ?
\\
\end{tabular}
\end{center}



\newpage

\item Parameter passing

  
Consider the following program. It uses the ``call by reference''
calling convention.

\begin{verbatim}
f (a, b : integers passed by reference) {    
    a := b
    b := b + 3;
    return t
}

x, y: integer
x := 2;
y := 4;
f(x,y)
x := y + 1;
print (x + y);
\end{verbatim}

What is printed?
\hfill{\textbf{[2 points]}}

Translation to call-by-value. \hfill{\textbf{[6 points]}}

Translate the function \verb!f! \emph{and} its call to a language
that does not support call by reference, but only call by value. Do
so using pointers (use operators \verb!*! and \verb!&!). You are
not allowed to change anything else. In particular, the
``algorithm'' and the declatations of \verb!x! and \verb!y! must
remain the same.

\end{itemize}


\newpage
\section{Object-Oriented Programming [12 points]}

\begin{itemize}

\item Subtyping.

\begin{enumerate}
\item State the substitution principle of Liskov. \hfill{\textbf{[3 points]}}

\item I claim that every type is a subtype of itself. Show that this claim is compatible with 
  the above statement (your answer to the above question) by specialising it. \hfill{\textbf{[3 points]}}
\end{enumerate}

\item Algebraic specification.

Consider the following axioms to describe semantics of a sort
\verb!S!.

\begin{verbatim}
contains (x, empty) = false
contains (x, insert (x,s)) = true
contains (x, insert (y,s)) = contains (x, s) (assuming x /= y)
remove (x, empty) = empty
remove (x, insert (x,s)) = s
remove (x, insert (y,s)) = insert (y, remove (x,s)) (assuming x /= y)
insert (x, insert (y,s)) = insert (y, insert (x,s))
\end{verbatim}

\begin{enumerate}
\item 
Write the signature for all operations of the sort \verb!S!. \hfill{\textbf{[4 points]}}

(Assume the sort \verb!Element! for elements, and that Booleans are
pre-defined) 

\item An ADT which implements this specification must remember the
  number of times that an element is inserted. That is, inserting the same
  element two times is not the same as inserting it once.

Is the previous statement true or false? \hfill{\textbf{[2 points]}}

\end{enumerate}


\end{itemize}


\newpage


\end{document}
