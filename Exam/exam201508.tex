\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{minted}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}

\usepackage{pgf, tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows}


\newcommand{\Blue}[1]{\color{blue}#1\color{black}\xspace}

\usepackage{array}
% This is needed because raggedright in table elements redefines \\:
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\let\PBS=\PreserveBackslash

%%%%%%%%%%%%%%
\newcommand{\solution}[1] {}
%\newcommand{\solution}[1] {\textbf{Solutions:}\\ #1}

%\newcommand{\comment}[1]{}
%% \newcommand{\answer}[0]{\paragraph{Answer:}}
\newcommand{\answer}[1]{}
\newcommand{\comment}[1]{\marginpar{#1}}


\begin{document}

\setlength{\parskip}{2pt}

\newcommand{\examtime}{Afternoon, August 28th  (Location:M)}
\newcommand{\points}[1]{\marginpar{\bf #1 points}}
\noindent
\begin{tabular}{lr}
CHALMERS TEKNISKA H\"OGSKOLA &\examtime{}.\\
Dept. of Computer Science and Engineering & Programming Paradigms\\
Jean-Philippe Bernardy                 & DAT121 / DIT331(GU) \\
\end{tabular}

\vspace{2.5cm} \noindent
\begin{center} {\LARGE
Exam in Programming Paradigms}
\end{center}

\vspace{1.5cm}

\noindent
\examtime{}.\\
\begin{tabular}{ll}
\textbf{Examiner:} & Jean-Philippe Bernardy \\
\textbf{Permitted aids:} & Pen and blank paper.
\end{tabular}
\vspace{1cm}

\noindent
% English-Swedish or English-other language dictionary.

There are 5 questions, each worth 12 points. The total sum is 60
points.

Some questions come with \emph{remarks}: you must take those
into account.
Some questions come with \emph{hints}: even though they are meant to help you, you may ignore those.

You will be asked to write programs in various paradigms. Choose the
language appropriately in each case, and indicate which you choose at
the beginning of your answer.

\begin{tabular}[p]{cc}
  Paradigm & Acceptable language \\ \hline
  Imperative   & C or (an OO language where you refrain to use Objects) \\
  Object oriented & C++ or Java \\
  Functional & Haskell, ML \\
  Concurrent & Erlang, Concurrent-Haskell \\
  Logic & Prolog, Curry
\end{tabular}

You may also use pseudo-code resembling an actual language in the
relevant list. In that case, make sure your code can only be
interpreted in the way you intent (the responsibility lies with
you). In particular, in the case of functional/logic languages,
omitting necessary parentheses is NOT acceptable: \texttt{a b c} means
\texttt{(a b) c} and is not acceptable pseudo-code for \texttt{a (b
  c)}.


\textbf{Chalmers:}
24 points is required to pass (grade 3), 36 points is required for
grade 4, and 48 points is required for grade 5.

\textbf{GU:}
24 points is required to pass (grade G) and 42 points is
required for grade VG.


\section{Substitution Model and Closures}

The following evaluator for a simple functional language is missing
two lines. Your task is to fill the gap and explain the implementation
mechanism.


\begin{minted}{haskell}
data Expr = Val Value
          | Bin (Int -> Int -> Int) Expr Expr
          | App Expr Expr
          | Lam String Expr
          | Var String
data Value = Fun (Value -> Value)
           | Number Int

eval :: Expr -> Value
eval e0 = case e0 of
  App f e -> -- (1)
  Lam x e -> -- (2)
  Val x -> x
  Bin op e1 e2 -> let (Number x,Number y) = (eval e1,eval e2)
                    in Number (op x y)

subst :: String -> Value -> Expr -> Expr
subst what for e0 = case e0 of
  Lam x e | x == what -> Lam x e
  Lam x e | x /= what -> Lam x (subst what for e)
  App a b -> App (subst what for a) (subst what for b)
  Bin op a b -> Bin op (subst what for a) (subst what for b)
  Var x | x == what -> Val for
  Var x | x /= what -> Var x
  Val v -> Val v
\end{minted}

\begin{enumerate}
\item Consider the \texttt{Value} data type. Which constructor is used
  for functional values? \points{1}

\item Consider the code to write in place of \texttt{(1)}, which is
  evaluating the application of a function \texttt{f} to an argument
  \texttt{e}. In order to yield the expected constructor for the recursive
  evaluation of \texttt{f}, the input expression must satisfy a certain well-formedness condition.
  State this condition. \points{2}

\item Write the code for \texttt{(1)}. Hint: you may assume the condition
  stated at the previous point. \points{3}

\item Consider the code to write in place of \texttt{(2)}, which
  evaluates a lambda abstraction ($\lambda$\texttt{x}. \texttt{e}) to a closure. What constructor
  should you return? \points{1}

\item Which Haskell mechanism is used to represent the created
  closure. \points{2}

\item Write the code for \texttt{(2)}. Hint: use the auxilliary
  \texttt{subst} function. \points{3}

\end{enumerate}

\answer{
\begin{enumerate}
\item Fun
\item Input program well-typed
\item \texttt{let Fun f' = eval f in f' (eval e)}
\item Fun
\item a Haskell function (or a Haskell closure). We depend on the
  underlying host language mechanism to evaluate functions.
\item \texttt{Fun (\v -> eval (subst x v e))}
\end{enumerate}
}

\newpage
\section{Algebraic Data Types and Objects}
Consider the following Haskell code:
\begin{minted}{haskell}
data Expr = Const Int | Plus Expr Expr | Mult Expr Expr

eval (Const x) = x
eval (Plus x y) = eval x + eval y
eval (Mult x y) = eval x * eval y
\end{minted}

Translate the code to an object oriented language. 

\begin{itemize}
\item Write an interface corresponding to the declaration of \texttt{Expr}. It should contain a method corresponding to \texttt{eval} \points{4}
\item Write a class for for the \texttt{Const} case. \points{4}
\item Write a class for for the \texttt{Plus} case. \points{4}
\end{itemize}

Hint: you may leave the \texttt{Mult} case out, as it is the same as \texttt{Plus}.
\answer{
  \begin{minted}{java}
    interface Expr { int eval(); }

    class Const implements Expr { int value; int eval() {return
        value;} }

    class Plus implements Expr { Expr l; Expr r; int eval() {return
        r.eval() + r.eval();} 
    }
\end{minted}
}

\newpage

\section{Explicit Stacks, Recursion}

Consider the following program, solving the Hanoi towers problem:

\begin{minted}{c}
  void hanoi(int n,int s,int i,int d) {
    if (n>0) {
      hanoi(n-1,s,d,i);
      move_disk(s,d);
      hanoi(n-1,i,s,d);
    }
  }
\end{minted}


Here is an equivalent implementation of it, but using an explicit
stack:

\begin{minted}{c}
struct stack {
  int n; int s; int i; int d; int caller;
  struct stack* next;
};

struct stack* stk = NULL;

void push(int n, int s, int i, int d, int caller) {
  struct stack* prev = stk;
  stk = malloc (sizeof (struct stack));
  stk -> n = n;
  stk -> s = s;
  stk -> i = i;
  stk -> d = d;
  stk -> caller = caller;
  stk -> next = prev;
}

void pop() {stk = stk-> next;}

\end{minted}
Continued on next page.
\newpage
\begin{minted}{c}
void move_many(int n, int s, int i, int d) {
  push(n,s,i,d,0);                         // 1
 call:                                     // 2
  if (stk->n!=0) {                         // 3
    push(stk->n-1,stk->s,stk->d,stk->i,1); // 4
    goto call;                             // 5
  loc1:                                    // 6
    pop();                                 // 7
    move_disk(stk->s,stk->d);              // 8
    push(stk->n-1,stk->i,stk->s,stk->d,2); // 9
    goto call;                             // 10
  loc2:                                    // 11
    pop();                                 // 12
  }
  int caller = stk->caller;                // 13
  if (caller == 1) goto loc1;              // 14
  if (caller == 2) goto loc2;              // 15
}
\end{minted}

The point of this exercise is to identify the tail call and optimise
it. To implement the tail call optimisation, one line has to be
replaced, and others are to be completely deleted (no replacement).

\begin{enumerate}
\item Which is the goto that corresponts to the tail call? Give the
  line number.\points{2}

\item Which line has to be replaced? \points{3}
\item What is the code replacing that line? \points{4}
\item What are the line(s) that can be simply deleted? Remark: there
  are some lines that can be kept while not changing the meaning of
  the code. List them anyway.  \points{3}

\end{enumerate}

\answer{
\begin{enumerate}
\item 10
\item 9
\item
Replacement:
\begin{minted}{c}
  stk->n = stk -> n-1;
  int tmp = stk->s;
  stk->s = stk -> i;
  stk->i = tmp;
\end{minted}
\item 11, 12, 15

\end{enumerate}

}
\newpage
\section{State-Management Process}
Assume a language without pointers nor variables, but support for
concurrency. In particular, assume primitives for creating processes
and channels, and primitives for reading and writing to to
channels. For example C++-style:

\begin{minted}{cpp}
Chan<A> newChan();
A readChan(Chan<A> c);
void writeChan(Chan<A> c,A x);
void forkProcess(*void());
\end{minted}
or Haskell-style:
\begin{minted}{haskell}
newChan :: IO (Chan a)
readChan :: Chan a -> IO a
writeChan :: Chan a -> a -> IO ()
forkProcess :: IO () -> IO ()
\end{minted}

Your task is to simulate references to mutable variables using the
above primitives. This can be done be using a process that manages the
variable state.

\begin{enumerate}
\item Define the representation for a variable of type ``reference to
  Integer''. Name this type \texttt{Reference}. \points 3
\item Write the code for the process that manages the variable state. \points 4
\item Write the code for primitives to create, read and write references. \points 3
Their type should be:
\begin{minted}{cpp}
Reference newRef();
int readRef(Reference);
void writeRef(Reference, int);
\end{minted}
or Haskell-style:
\begin{minted}{haskell}
newRef :: IO Reference
readRef :: Reference -> IO Int
writeRef :: Reference -> Int -> IO ()
\end{minted}
\item Explain what happens during a \texttt{readRef} operation. In particular:
  \begin{enumerate}
  \item How many channel(s) are used? \points 1
  \item For each of the channel(s), how many message(s) are sent?  \points 1
  \end{enumerate}
\end{enumerate}

Hint: The channels can transmit any type of information, including
references to channels.

Remark: You can use either a functional or imperative language to
write your answer, however you may not use any global variable nor
primitive reference types in it.

\answer{
\begin{minted}{haskell}
data Command a = Get (Chan a) | Set a
type Variable a = Chan (Command a)

handler :: Variable a -> a -> IO ()
handler v a = do
  command <- readChan v
  case command of
    Set a' -> handler v a'
    Get c -> do
      writeChan c a
      handler v a

newVariable :: a -> IO (Variable a)
newVariable a = do
  c <- newChan
  forkIO (handler c a)
  return c

get :: Variable a -> IO a
get v = do
  c <- newChan
  writeChan v (Get c)
  readChan c

set :: Variable a -> a -> IO ()
set v a = do
  writeChan v (Set a)
\end{minted}
}

\newpage
\section{Relations to lists of satisfying results}

Consider the Curry program
\begin{verbatim}
ancestor a c = a =:= c
ancestor a c = (parent a x & ancestor x c)
\end{verbatim}
or the equivalent Prolog program
\begin{verbatim}
ancestor(A,A).
ancestor(A,C) :- parent(A,X), ancestor(X,C).
\end{verbatim}


Convert the program from relational to functional style. That is,
write a function \texttt{ancestors} that returns all the ancestors of
a given person.  More precisely, given a person \texttt{c}, construct the
list of \texttt{x}s such that \texttt{ancestor x c} holds.

To do so, you may assume that you have at your disposal a function
\texttt{parents} which returns the list of \texttt{x}s such that
\texttt{parent x c} is true.

\begin{enumerate}
\item Write the type of the \emph{function} \texttt{parents}. \points{3}
\item Write the type of the \emph{function} \texttt{ancestors}.\points{3}
\item Write the body of the \emph{function} \texttt{ancestors}.\points{6}
\end{enumerate}


Hint:
\begin{itemize}
\item Remember that in Curry, \texttt{|} stands for logical disjunction and
  \texttt{\&} stands for logical conjunction.
\end{itemize}



\end{document}
