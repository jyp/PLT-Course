\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{listings}
\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small\ttfamily}}{}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}

\usepackage{pgf, tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows}

\lstdefinelanguage{FSharp}
      {morekeywords={let, new, match, inherit, abstract, with, rec,
          open, module, namespace, type, of, member, and, for, in, do,
          begin, end, fun, function, try, mutable, if, then, else,
          class, interface, end},
    keywordstyle=\color{blue},
    basicstyle = \small,
    sensitive=false,
    morecomment=[l][\color{green!50!black!80}]{///},
    morecomment=[l][\color{green!50!black!80}]{//},
    morecomment=[s][\color{green!50!black!80}]{{(*}{*)}},
    morestring=[b]",
    stringstyle=\color{red},
    columns=fullflexible
    }


\lstdefinelanguage{Smalltalk}{
  basicstyle=\ttfamily,
  keywordstyle=\bfseries,
  morekeywords={self,super,true,false,nil,thisContext}, % This is overkill
  morestring=[d]',
  morecomment=[s]{"}{"},
  alsoletter={\#:},
  escapechar={!},
}[keywords,comments,strings]


\newcommand{\Blue}[1]{\color{blue}#1\color{black}\xspace}


\usepackage{array}
% This is needed because raggedright in table elements redefines \\:
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\let\PBS=\PreserveBackslash

%%%%%%%%%%%%%% 
\newcommand{\solution}[1] {}
%\newcommand{\solution}[1] {\textbf{Solutions:}\\ #1}

%\newcommand{\comment}[1]{}
\newcommand{\comment}[1]{\marginpar{#1}}


\begin{document}
\newcommand{\examtime}{14:00, Thursday August 18th, 2011}
\newcommand{\points}[1]{\marginpar{\bf #1 points}}
\noindent
\begin{tabular}{lr}
CHALMERS TEKNISKA H\"OGSKOLA &\examtime{}.\\
Dept. of Computer Science and Engineering & Programming Paradigms\\
John Hughes                  & DAT120 / DIT330(GU) \\
\end{tabular}

\vspace{2.5cm} \noindent
\begin{center} {\LARGE
Exam in Programming Paradigms}
\end{center}

\vspace{1.5cm}

\noindent
\examtime{}.\\
\begin{tabular}{lllc}
\textbf{Lecturer:} &  John Hughes  &  - & (Examiner)\\
\textbf{Lecturer:} & Richard Bubel & tel 073 965 7355 & \\ 
\end{tabular}
\vspace{1cm}

\noindent
Permitted aids:\\
English-Swedish or English-other language dictionary.

There are 5 questions: one on functional
programming (12 points), one on concurrency oriented programming (12
points), one on basic imperative and object-oriented concepts (12
points), one on object-oriented programming (12 points) and one on
logic programming (12 points).

The total sum is 60 points.


\textbf{Chalmers:}
24 points is required to pass (grade 3), 36 points is required for
grade 4, and 48 points is required for grade 5. 

\textbf{GU:}
24 points is required to pass (grade G) and 48 points is required for
grade VG.


\newpage

\section{Functional Programming [12 points]}

\begin{enumerate}

\newcommand{\id}[1]{\mbox{\it #1}}

\item Given that
\begin{eqnarray*}
\id{twice} &=& \lambda f.\lambda x.f~(f~x)
\end{eqnarray*}
show how to simplify 
\[ \id{twice}~\id{twice}~f~x \]
as far as possible using $\beta$-reductions.  Apply $\beta$-reductions
one at a time, and write out the result of each step explicitly.
\points{2}

\item 
Study the following Haskell definition of the list append function:
\begin{verbatim}
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
\end{verbatim}
List structures can be drawn diagrammatically using boxes to represent
{\em cons} cells and arrows to represent pointers\dots for example, if
\verb!xs! is the list \verb![1,2]!, then the heap containing it can be drawn
as:
\begin{center}
\includegraphics[width=7cm]{List.jpg}
\end{center}
{\em Copy this diagram}, and add to your drawing the list \verb!ys! defined by
\begin{verbatim}
ys = xs ++ xs
\end{verbatim}
Make sure that any sharing in the heap is shown accurately in your diagram.
\points{1}

\item
Study the following Haskell definitions:
\begin{verbatim}
take 0 xs     = []
take n []     = []
take n (x:xs) = x:take (n-1) xs

drop 0 xs     = xs
drop n []     = []
drop n (x:xs) = drop (n-1) xs
\end{verbatim}

Assume \verb!xs! is a list of at least \verb!n! elements.
\begin{enumerate}
\item
What are the values of \verb!take 3 [1,2,3,4,5]! and \verb!drop 3 [1,2,3,4,5]!?
\points{1}
\item
How many new cons cells are allocated during the evaluation of \verb!take n xs!?
\points{1}
\item
How many new cons cells are allocated during the evaluation of \verb!drop n xs!?
\points{1}
\item
What well-known compiler optimization is applicable to \verb!drop!, but not to \verb!take!?
\points{1}
\end{enumerate}


\item
QuickCheck properties take the form of boolean functions whose result
should always be true. For example,
\begin{verbatim}
prop_twice_increment x =
  twice (+1) x == x + 2
\end{verbatim}
\begin{enumerate}
\item
Complete the following definitions so that they become true QuickCheck
properties, by replacing \verb!???! in each case by a suitable
expression ({\em different} from the left hand side, of course!).
\begin{verbatim}
prop_twice_drop n xs =
  twice (drop n) xs == ???

prop_twice_take n xs =
  twice (take n) xs == ???
\end{verbatim}
\points{2}
\item
Propose a QuickCheck property relating \verb!take!, \verb!drop!, and \verb!++!.
\points{1}
\end{enumerate}

\item
The Haskell standard {\em higher-order function} \verb!foldr! combines
the elements of a list using a two-argument function:
\[ \verb!foldr!~f~z~[x_1,x_2,\cdots,x_n] =
f~x_1~(f~x_2~(\cdots(f~x_n~z)\cdots)) \]
(Of course, this is not a valid Haskell definition, just an
illustration of what \verb!foldr! computes).
The standard function \verb!insert! inserts an element into an ordered
list, for example
\[ \verb!insert 4 [1,3,5,7]! = \verb![1,3,4,5,7]! \]
Define a function
\begin{verbatim}
sort :: [Integer] -> [Integer]
\end{verbatim}
to sort lists, by making use of \verb!foldr! and \verb!insert!
appropriately.
\points{2}

\end{enumerate}

\newpage
\section{Concurrency Oriented Programming [12 points]}

\begin{enumerate}
\item
How are Erlang data structures protected against simultaneous
modification by concurrent processes?
\points{1}

\item
Study the following code, which starts a server managing an integer value:
\begin{verbatim}
server() ->
    spawn(fun() -> server(0) end).

server(N) ->
    receive
        {read,Pid} ->
            Pid ! {self(),N},
            server(N);
        {write,New} ->
            server(New)
    end.
\end{verbatim}
Write the following functions for use in clients of the server:
\begin{enumerate}
\item
\verb!read(ServerPid)!, which returns the value \verb!N! currently managed by the server,
\points{1}
\item
\verb!write(ServerPid,New)!, which updates the value currently managed by the server to \verb!New!.
\points{1}
\end{enumerate}

\item
What value(s) can the following function return:
\begin{verbatim}
test() ->
    Server = server(),
    spawn(fun() -> write(Server,read(Server)+1) end),
    spawn(fun() -> write(Server,read(Server)+2) end),
    read(Server).
\end{verbatim}
\points{1}

\item
What happens if a message such as \verb!{lock,Pid}!, that does not
match any of the patterns in the \verb!receive! clause, is sent to the
server?
\points{1}

\item
In the rest of the question, we will extend the server to handle two
new requests,
\begin{itemize}
\item to {\em lock} the server, and return its current value, and
\item to {\em unlock} the server again, and update its value.
\end{itemize}
After accepting a \verb!lock! request, the server should defer all
other requests until after it has handled an \verb!unlock! request
from the same client. After calling \verb!lock!, a client {\em must}
call \verb!unlock! before making any other requests of the server; a
client {\em must not} call \verb!unlock! without a preceding call of
\verb!lock!. You can assume that all clients follow this protocol.

First, write the {\em client-side} code: define the following
functions for use in clients:
\begin{enumerate}
\item
\verb!lock(ServerPid)!, which locks the server and returns the value
\verb!N! it currently manages, and
\points{1}
\item
\verb!unlock(ServerPid,New)!, which updates the value currently
managed by the server to \verb!New!, and permits other clients to use
the server again.
\points{1}
\end{enumerate}
These functions should never fail (provided the server is
running)---in other words, the client-side code can assume that it
will receive a correct response from the server.

\item
Write the code which must be added to the \verb!server(N)! function to
handle these two new requests. Remember the server may only send
correct responses to the clients!
\points{2}

\item
What happens (to the server and other clients) if a client crashes
after calling \verb!lock(Server)!, but before calling
\verb!unlock(Server,New)!?
\points{1}
\item
What is the effect of calling \verb!link(Pid)! in an Erlang process?
\points{1}
\item
How would you make the server {\em fault-tolerant}, so that if a
client crashes while holding the lock, then the server and other
clients are unaffected?  Show the code that you would add to the
\verb!server(N)! function.  \points{1}


\end{enumerate}


\newpage

\section{Basic Imperative and Object-Oriented Concepts [12 points]}
\lstset{language=Java, columns=flexible}

\begin{enumerate}
\item Describe the computation workflow of the \emph{von Neumann
    computing model}.\points{2}
\item Let \lstinline!A! be a class with an integer typed attribute
  \lstinline!a!.
\begin{lstlisting}[language=Java, columns=flexible]
class A {  int a;  }
\end{lstlisting}

and the following program fragment
\begin{lstlisting}[language=Java, columns=flexible] 
A x; A y;
...
// x and y point to different objects
x.a = 1;
y.a = 5;

x = y;

x.a = x.a + y.a;   
y.a = x.a - y.a;
x.a = x.a - y.a; (*)
\end{lstlisting}
where the program variables \lstinline!x! and \lstinline!y! refer
initially to different objects.

Give the values of \lstinline!x.a! and \lstinline!y.a! after execution
of line \lstinline!(*)! if the assignment operator is realised using
\begin{enumerate}
  \item copy semantics 
  \item reference semantics 
\end{enumerate}
\points{2}
\item For what should the equality operator test to be compatible with
  an assignment operator implementing 
  \begin{enumerate}
  \item copy semantics?
  \item reference semantics?
 \end{enumerate}\points{1} 
\item Consider the following program:
\begin{lstlisting}[language=Java, columns=flexible] 
int g(int b, int c) {
  if (b < c) {
    return g(c,b); 
  }
  if ( c > 0 ) 
     return b + g(b, c - 1);
  }
  return 0; (*)
}
\end{lstlisting}

Consider the call 
\begin{center}
  \lstinline[language=Java, columns=flexible]{g(3, 5);} 
\end{center}
Give the number of activation records on the stack resulting from the
above call just before returning from (*), i.e., directly after
assigning the return value, but before popping the last activation
record from the stack. Give also the last two activation records on
top of the stack (the last allocated ones). State their order
explicitly and name all slots/components of the activation record and
their content explicitly. If a content is not yet defined use
'\texttt{?}' as value. \points{3}
\item Consider the following program
\begin{lstlisting}[language=Java, columns=flexible] 
void f(by-?? int a, by-?? int b, by-?? int c) {
  a = a + a;
  b = a + b + c;
  c = c + 15;
}

 ..
 int i, j;
 i = 1; 
 j = 5;
 f(i+1, i, j); //(*)
\end{lstlisting}

What are the values of the variables \lstinline!i! and \lstinline!j!
at (*) after the method \lstinline!f! returns if
\begin{enumerate}
  \item all parameters are passed \emph{by-copy}
  \item parameter \lstinline!a! is passed \emph{by-copy} and
    the parameters \lstinline!b! and \lstinline!c! \emph{by-reference}
  \item the parameters \lstinline!a! and \lstinline!b! are passed by
    copy and parameter \lstinline!c! \emph{by-value-result}. 
  \item parameter \lstinline!a! is passed \emph{by-name}, parameter
    \lstinline!b! is passed \emph{by-reference} and parameter
    \lstinline!c! is passed \emph{by-copy}.
\end{enumerate} \points{4}
\end{enumerate}

\solution{
\begin{enumerate}
\item (Each item below 0.5 points) The CPU 
  \begin{enumerate}
  \item  reads next instruction from memory (indexed by program counter PC)
    Memory
  \item fetches required data from memory
  \item operates on data
  \item writes result back to memory and updates PC
  \end{enumerate}
\item
  \begin{enumerate}   
  \item \lstinline!x.a!: 5 \quad  \lstinline!y.a!: 5
  \item \lstinline!x.a!: 0  \quad \lstinline!y.a!: 0
  \end{enumerate}
\item 4 activation records are on the stack; the last two ones
  $A_1$, $A_2$ where $A_2$ is the one on top of the stack are defined
  as follows: $A_1=(8,1,?,\text{ref to}~A_{0} , ?)$ (first two parameters,
  third local variable, fourth reference to first activation record,
  fifth return value), $A_2=(8,0, \text{ref to}~A_1, 0)$  
\item\hfill\\
  \begin{tabular}{lcc}
    & \lstinline!i! & \lstinline!j! \\ \hline
   (a) &  1 & 5 \\
   (b) & 10 & 20 \\
   (c) & 1 & 20 \\
   (d) & 14 & 5 \\
  \end{tabular}

  
\end{enumerate}
}

\newpage

\section{Object-Oriented Programming [12 points]}

\begin{enumerate}
\item Given two classes $A$ and $B$, where $B$ inherits from $A$. Both
  classes declare a field of the same name $f$.  Name and explain two
  possibilities to resolve such field name clashes.\points{2}
\item Explain the difference between replicated and shared
  inheritance. \points{2}
\item Given the following class
  hierarchy \\
\begin{center}

\begin{tikzpicture}
\node[draw, 
   rectangle split, 
   rectangle split parts=3, 
   minimum width=2cm] (A) at (5,4) 
  {A 
     \nodepart{second} \ldots 
     \nodepart{third} \phantom{\textbf{void} h(A x)}};
\node[draw, 
   rectangle split, 
   rectangle split parts=3, 
   minimum width=2cm] (B) at (5,2) 
  {B 
     \nodepart{second} \ldots 
     \nodepart{third} \textbf{void} m(? p)};
\node[draw, 
   rectangle split, 
   rectangle split parts=3, 
   minimum width=2cm] (C) at (3,0) 
  {C 
    \nodepart{second} \ldots 
    \nodepart{third} \textbf{void} m(\textbf{B} p)};   

\node[draw, 
   rectangle split, 
   rectangle split parts=3, 
   minimum width=2cm] (D) at (7,0) 
  {D 
     \nodepart{second} \ldots 
     \nodepart{third} \textbf{void} m(\textbf{C} x)};

\draw[open triangle 90-] (A) -- (B);
\draw[open triangle 90-] (B) -- (C);
\draw[open triangle 90-] (B) -- (D);
\end{tikzpicture}
\end{center}
defining all available classes. Note: Class \lstinline!A! does not
define any method.
Give for each of the following overriding semantics (for arguments):
\begin{enumerate}
  \item co-variance,
  \item contra-variance and
  \item invariance
\end{enumerate}
\emph{all} possible argument types for method
\lstinline!m! in class \lstinline!B! such that
\lstinline!m! is overridden by the method \lstinline!m! declared in
class \lstinline!C! and class \lstinline!D!. \emph{Hint:} There might
not be a solution for all semantics in that case write ``not possible''.  \comment{\textbf{3 points}}\newpage
\item Given the following class hierarchy:\\
\begin{tikzpicture}
\node[draw, 
   rectangle split, 
   rectangle split parts=3, 
   minimum width=2cm] (A) at (5,6) 
  {   A 
     \nodepart{second} \ldots 
     \nodepart{third} \textbf{void} m(\textbf{A} x)};
\node[draw, 
   rectangle split, 
   rectangle split parts=3, 
   minimum width=2cm] (B) at (5, 4) 
  {   B 
  };

\node[draw, 
   rectangle split, 
   rectangle split parts=3, 
   minimum width=2cm] (C) at (3,2) 
  {C 
     \nodepart{second} \ldots 
     \nodepart{third} \textbf{void} m(\textbf{C} x)
  };
 \node[draw, 
    rectangle split, 
    rectangle split parts=3, 
    minimum width=2cm] (D) at (7,2) 
  {D
    \nodepart{second} \ldots 
    \nodepart{third} \textbf{void} m(\textbf{B} x)};   

\draw[open triangle 90-] (A) -- (B);
\draw[open triangle 90-] (B) -- (C);
\draw[open triangle 90-] (B) -- (D);
\end{tikzpicture}

The visibility of method \lstinline!m! is public. Overriding semantics
for methods is such that the method \lstinline!m!  of class
\lstinline!C! as well as the method \lstinline!m! of class
\lstinline!D! override the method \lstinline!m! defined in class
\lstinline!A!. Class \lstinline!B! does not (re-)implement method
\lstinline!m!.

In addition there is a method \lstinline!g! 
\begin{lstlisting}[language=Java, columns=flexible]
void g(A x, B y) {
   x.m(y);
}
\end{lstlisting}

Which of the three implementations of method \lstinline!m! is invoked by
\lstinline!g! if
\begin{enumerate}
\item the programming language uses \emph{single-dynamic dispatch} and
  the call statement is
 \begin{enumerate}
    \item \lstinline!g(new C(), new B());!
    \item \lstinline!g(new C(), new C());!
    \item \lstinline!g(new D(), new C());!
  \end{enumerate}
  \item the programming language uses \emph{multi-dynamic dispatch}
    and the call statement is
 \begin{enumerate}
    \item \lstinline!g(new C(), new D());!
    \item \lstinline!g(new C(), new C());!
    \item \lstinline!g(new D(), new C());!
    \end{enumerate}
\end{enumerate}\points{3}\newpage
\item Which of the following statements are true\\
    \begin{tabular}{|p{6cm}|c|c|}\hline
      & True & False \\ \hline
      a) F\# does not allow to declare new classes. It can only reuse
      existing ones to be able to interact with the \texttt{.net} environment. & & \\\hline
      b) In F\# mutable variables can be be assigned different values, whereas
      the values stored inside reference cells are immutable. & & \\\hline
      c) Current versions of F\# do not support concurrency. & & \\\hline
      d) In Smalltalk the only two types are integers and objects. & & \\\hline
   \end{tabular}\\
   For your answer draw that table but refer to the statements by a),
   b) etc. instead of writing them again. Wrong answers lead to a
   reduction of points, a negative result does not carry over to other
   sub-assignments. \points{2}
\end{enumerate}

\solution{
\begin{enumerate}
\item For example, by renaming (compiler error; programmer has to
  rename field explicitly) and/or shadowing (both field co-exist;
  complexer access rules)
\item \emph{Replicated Inheritance}: child object contains  multiple
  copies of fields/methods; 
  \emph{Shared (diamond)  Inheritance} child object contains only one
  superclass object.
\item 
    \begin{enumerate}
      \item A, B
      \item C
      \item not possible
    \end{enumerate}
\item 
    \begin{enumerate}
    \item 
    \begin{enumerate}
    \item method \lstinline!m! as defined in class \lstinline!A!
    \item method \lstinline!m! as defined in class \lstinline!A!
    \item method \lstinline!m! as defined in class \lstinline!D!
 \end{enumerate}
    \item 
    \begin{enumerate}
    \item method \lstinline!m! as defined in class \lstinline!A!
    \item method \lstinline!m! as defined in class \lstinline!C!
    \item method \lstinline!m! as defined in class \lstinline!A!
    \end{enumerate}
    \end{enumerate}
\item
      \begin{tabular}{|p{6cm}|c|c|}\hline
      & True & False \\ \hline
       a) F\# does not allow to declare new classes. It can only reuse
      existing ones to be able to interact with the \texttt{.net}
      environment. & & X \\\hline
      b) In F\# mutable variables can be be assigned different values, whereas
      the values stored inside reference cells are immutable. & & X \\\hline
      c) Current versions of F\# do not support concurrency. & & X \\\hline
      d) In Smalltalk the only two types are integers and objects. & &
      X \\\hline
   \end{tabular}\\

\end{enumerate}
}

\newpage
\section{Logic Programming [12 points]}

\begin{enumerate}
\item
Given the three clauses
\begin{enumerate}
\item \verb!A || B!
\item \verb?!A || D?
\item \verb!C || D!
\end{enumerate}
state {\em which two} of the clauses can be combined using a resolution step, and give the resulting clause.
\points{1}

\item
For each pair of terms below, state whether the terms can be unified,
and if so, give the variable bindings that result. For example,
\verb!X! and \verb!2! {\em can} be unified, and the result is
\verb!X=2!.
\begin{enumerate}
\item \verb![X|Xs]! and \verb![1,2,3]!
\item \verb![X]! and \verb![]!
\item \verb!pear(A,banana)! and \verb!pear(apple,B)!
\item \verb!X! and \verb!Y!
\item \verb!pear(A,A)! and \verb!pear(B,C)!
\item \verb!pear(A,A)! and \verb!pear(apple,banana)!
\end{enumerate}
\points{3}

\item
Study the following Prolog program:
\begin{verbatim}
isa(john,human).
isa(human,mammal).
isa(cat,mammal).
isa(dog,mammal).
isa(mammal,vertebrate).
isa(jellyfish,invertebrate).
isa(vertebrate,animal).
isa(invertebrate,animal).
isa(chanterelle,fungus).
\end{verbatim}
What solutions will Prolog find for the following goals?
\begin{enumerate}
\item
\verb!isa(X,mammal).!
\item
\verb!isa(john,Y)!
\end{enumerate}
\points{2}

\item
It is tempting to add a clause
\begin{verbatim}
isa(X,Y) :- isa(X,Z), isa(Z,Y).
\end{verbatim}
to enable Prolog to conclude that \verb!john! is a \verb!vertebrate!,
for example, by transitive reasoning (because \verb!john! is a
\verb!human!, which is a \verb!mammal!, which is a
\verb!vertebrate!). Explain why adding this clause would not work.
\points{1}

\item
Extend the program above to perform transitive reasoning by defining a
new predicate \verb!is_transitively_a!, such that (among other things)
Prolog can draw the conclusion
\verb!is_transitively_a(john,vertebrate)!.
\points{2}

\item
What solutions would Prolog find for the goal
\verb!is_transitively_a(X,mammal)!?
\points{1}

\item
Let us call any Y for which \verb!isa(X,Y)! succeeds a
``category''---for example, \verb!human!, \verb!mammal! and
\verb!fungus! are all categories, but \verb!john!, \verb!cat! and
\verb!dog! are not.  Write a query to find all \verb!animal!s, which
     {\em does not} include any ``categories'' in its result. For
     example, your query should include \verb!john! and \verb!cat! and
     \verb!dog! in its results, but should {\em not} include
     \verb!human! or \verb!mammal!.
{\em Hint:} you may find the Prolog `cut' useful.
\points{2}
\end{enumerate}


\end{document}
