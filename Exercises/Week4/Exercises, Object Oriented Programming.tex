\documentclass{article}
\usepackage{fancyvrb,hyperref,listings,verbatim}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}
\newcommand{\jp}[1]{ \footnote{#1}}

\lstset{language=java,basicstyle=\small}
\lstset{commentstyle=\textit,flexiblecolumns=true,mathescape=true}
\lstnewenvironment{java}
    {\lstset{language=java,frame=tb}}
    {}
\lstnewenvironment{java2}
    {\lstset{language=java,frame=tb}}
    {}
\lstnewenvironment{cplus}
    {\lstset{language=c++,frame=tb}}
    {}
\lstnewenvironment{perl}
    {\lstset{language=perl,mathescape=false,lineskip=0\baselineskip,frame=tb}}
    {}

\newcommand{\courseinfo}{ Sibylle Schupp \\ Programming Paradigms 2008 }
\newcommand{\percent}[1]{\protect \marginpar[l]{\bf [#1 points]}}
\newcommand{\mycomment}[1]{}

\newcounter{question}
\newenvironment{question}[1]{%
  \addtocounter{question}{1}%
  \paragraph{Exercise~\arabic{question}  \percent{#1}}%
}{%
  \vskip1em%
}

\let\longanswer=\comment
\let\endlonganswer=\endcomment
\newcommand{\answer}[1]{}

% Uncomment to show answers
%\renewenvironment{longanswer}{\paragraph{Answer~\arabic{question}}}{}
%\renewcommand{\answer}[1]{\begin{longanswer}#1\end{longanswer}}
  

\begin{document}
\title{Ex. 4: Programming Paradigms 
\\
Object-Oriented Programming}
\author{\courseinfo}
\date{}
\maketitle

\section{Co-, Contra-, Nonvariance \percent{6}}


\begin{java}
interface Monoid {
   Monoid op(Monoid second);
   Monoid id();
};

struct IntegerAdditiveMonoid : Monoid {
    public IntegerAdditiveMonoid(int x) { 
         elt = x;
    }    
    public IntegerAdditiveMonoid op(IntegerAdditiveMonoid second) { 
         return new IntegerAdditiveMonoid(
             elt + second.elt); 
    }
    public IntegerAdditiveMonoid id(){ 
         return new IntegerAdditiveMonoid(0);
    }
    int elt;
};

> gmcs Monoids.cs 
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement 
  interface member `Monoid.op(Monoid)'
Monoids.cs(2,11): (Location of the symbol related to previous error)
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement 
  interface member `Monoid.id()'
Monoids.cs(3,11): (Location of the symbol related to previous error)
Compilation failed: 2 error(s), 0 warnings

\end{java}
%

\begin{question}{1} 
What is a \textit{monoid}, mathematically? 
Give two examples of data types that can be considered monoids, together with
the monoidal operation and its identity.

\answer{
  A monoid is a set of values, together with an associative binary operation and identity element.
  Examples: (int,+,0), (int,*,1), (float, +,0), (list, append, emptyList), (string, concat, emptyString), ...
}

\end{question}

\begin{question}{1} 
Note that the \textsf{Monoid} class we defined does not match the mathematical
definition of a monoid! What is the main difference?
\answer{
   The \textsf{Monoid} class makes no distinction between the \textsf{Monoid}
   itself and the data-type upon which it operates.
}

\end{question}

\begin{question}{1} 
The C\#-code above does not compile. 
Explain the error messages in terms of co-/contra-/nonvariance.
\answer{
    \textsf{op}'s parameter type is covariant. C\# requires nonvariance.
    \textsf{id}'s return type is covariant. C\# requires nonvariance.
}
\end{question}


\begin{question}{1} 
Imagine for the purpose of this question that the compiler did not raise the
error message about \textsf{op} and demonstrate that the C\# type system
would be \textit{unsound} if  the code would compile without error (i.e., one
could get a type error at run time).

Introduce another class that implements the \textsf{Monoid} interface. Write a
piece of code (3 lines), using \textsf{a.op(b)}, that results in a runtime
error.
\begin{longanswer}
Construct two objects from different monoids and combine them.
\begin{java}
    class StringConcatenative
         ...
    Monoid a = new StringConcatenative(...);
    Monoid b = new IntegerAdditiveMonoid(...);
    Monoid c = a.op(b);
\end{java}
\end{longanswer}
\end{question}

\begin{question}{1}
If you replace the call to op by a call to id in your code from the previous question, can
that lead to a runtime error?
\answer{
No error possible. 
}
\end{question}

\begin{question}{1}
Compiling the corresponding Java program would produce different results.
Briefly explain how Java handles parameter and return-type variance differently
in the example above. Be sure to back your answer with the appropriate clause(s)
in the JLS.
\answer{
    Java is covariant in the return type (JLS, 8,4,8.3). Therefore,
Java would only flag an error for the method op() (since it doesn't implement
the interface); the method id(), on the other hand, would be considered
an implementation.
}
\end{question}

\paragraph{Further reading}
\begin{itemize}
\item The Mono compiler is a free compiler for C\#. Read more about it
at

\url{http://www.mono-project.com/CSharp\_Compiler}

\item JLS is available on-line at 
\url{http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html}

\end{itemize}


\newpage
\section{Dynamic dispatching \& the visitor \percent{6}}

Suppose the three classes \textsf{Shape}, \textsf{Rectangle}, and 
\textsf{Circle}, where \textsf{Shape} is an abstract base class
for \textsf{Circle} and \textsf{Rectangle}.
Further assume a method \textsf{intersect()} that can determine whether two
shapes overlap. Obviously, the implementation of \textsf{intersect()} 
depends on the actual shapes involved, and your task is to experiment with
different means of selecting the right implementation.

\paragraph{Note}
The actual intersection algorithms, and their results, are not of interest.
Focus on the \emph{selection} of desired implementation.

\begin{question}{2}
Pick an object-oriented language with single-dispatch mechanism 
and design (using run time casts) the 3 classes so that all possible intersections
of shapes can be properly handled. 
Also, name at least 2 issues with single dispatching.

\begin{longanswer}
Issues with single-dispatch...
\begin{itemize}
\item Loss of static type safety.
\item Adding a new subclass requires updating all existing classes.
\item Run-time overhead due to explicity type-check and cast.
\end{itemize}
\begin{java}
abstract class Shape {
    public abstract boolean intersect(Shape s);
}

class Rectangle extends Shape {
    public boolean intersect(Shape s) {
        if (s instanceof Rectangle) 
            return ...;
        else if (s instanceof Circle)
            return ...; 
        else
            throw ...;
   }
}

// Same for Circle
\end{java}
\end{longanswer}
\end{question}

\begin{question}{2}
The following Java snippet redesigns the
class hierarchy using \textit{double dispatch}. 
Explain how double dispatching works by
giving the sequence of calls for the line marked (*) in \textsf{Main}.
Also name at least two problems with double dispatching.

\begin{java}
abstract class Shape {
    public abstract boolean intersect(Shape s);
    protected abstract boolean intersectRectangle(Rectangle r);
    protected abstract boolean intersectCircle(Circle c);
}
class Rectangle extends Shape {
    public boolean intersect(Shape s) {
        return s.intersectRectangle(this);  
    }
    protected boolean intersectRectangle(Rectangle r) { ... }
    protected boolean intersectCircle(Circle c) { ... }
}
class Circle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectCircle(this);  
    }
    // Same as Rectangle
}

class Intersect {
   public static void Main() {
      Shape s1 = new Rectangle(); 
      Shape s2 = new Circle();
      boolean b = s2.intersect(s1);        // *
   }
}
\end{java}

\begin{longanswer}
Issues with double dispatch:
\begin{itemize}
\item Root class needs to be modified each time a new class is added.
\item Run-time overhead due to multiple method calls.
\end{itemize}

\noindent Executed methods are:
  \textsf{Circle\#intersect(Shape)}, \textsf{Rectangle\#intersectCircle(Circle)}
\end{longanswer}
\end{question}

\noindent The \textit{Visitor pattern} provides an alternative workaround,
also based on double dispatching. In difference
to the solution above, the pattern introduces two hierarchies, the visited
hierarchy and the visitor hierarchy. In the example,
 \textsf{Shape, Rectangle, Circle}
form the visited hierarchy, \textsf{IntersectVisitor} and its two
subclasses \textsf{RectangleIntersectVisitor} and \textsf{CircleIntersectVisitor}
form the visiting hierarchy. The visited classes are
augmented with a method \textsf{accept}, which uses double dispatching
to call the appropriate ShapeVisitor (and to invoke the
right computation). 

\begin{question}{2}
Complete the code for the two class hierarchies by implementing
the classes \textsf{Rectangle}, \textsf{Circle}, \textsf{RectangleVisitor},
and \textsf{CircleVisitor}.
Once again name at least two problems of the visitor approach.

\begin{java2}
abstract class Shape {
    public abstract void accept(IntersectVisitor v);
    public abstract IntersectVisitor getIntersectVisitor();
    public boolean intersect (Shape s) {
	IntersectVisitor v = getIntersectVisitor();
	s.accept(v);
	return v.intersects;
    }
}
abstract class IntersectVisitor { 
    boolean intersects; 
    public abstract void visitRectangle(Rectangle r); 
    public abstract void visitCircle(Circle c); 
} 
\end{java2}

\begin{longanswer}
Problems with the visitor: 
\begin{itemize}
\item Arguments and return type have to be passed in a convoluted way.
\item One has to create a new (visitor) class for things that ``should'' be methods.
\item Code for handling visits is spread out over various classes.
\end{itemize}

\begin{java2}
class Circle extends Shape {
    public void accept(IntersectVisitor v) {
        v.visitCircle(this);
    }

    public IntersectVisitor getIntersectVisitor() {
        return new CircleIntersectVisitor(this);
    }
}

class CircleIntersectVisitor extends IntersectVisitor {
    public CircleIntersectVisitor(Circle left) {
        this.left = left;
    }
    public void visitCircle(Circle c) {
        // ...
    }
    public void visitRectangle(Rectangle r) {
        // ...
    }
    private Circle left;
}

// ... Same for Rectangle and RectangleIntersectVisitor
\end{java2}
\end{longanswer}
\end{question}

\paragraph{Further reading}
\begin{itemize}
\item MultiJava is a research language that implements multi-method:\\
\url{http://www.cs.washington.edu/research/projects/cecil/pubs/mj-toplas.pdf}
\item Another alternative to multi-methods are ``open methods.'' A
 proposal exists to extend the \Cpp\ language by ``open methods'', see
document no N2216=07-0076 by the standardization committee:

\url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2216.pdf}
\end{itemize}


\newpage
\section{Algebraic specification \percent{4}}

% References:
%  http://scom.hud.ac.uk/scomtlm/book/node221.html
%www.cs.colorado.edu/~kena/classes/5828/s00/lectures/lecture12.pdf


A standard example in algebraic specification is the data type \textit{stack}.
A textbook-like specification may support the following operations:
\begin{center}
\begin{tabular}[t]{ll}
 new & create a stack \\
 push & add an element to the top of the stack \\
 pop  & remove the top element from the stack \\
 top &  return the top element of the stack \\
 empty & return true exactly if there is no element on the stack
\end{tabular}
\end{center}

\begin{question}{1}
Write an algebraic specification of this stack: provide a full signature
and define its semantics through appropriate axioms. 

In your specification,
make reasonable assumptions about what a stack (informally) is; you
may ``import'' other specifications. Make explicit which operations
you consider as \textit{generators} (constructors) and informally argue why your
set of axioms is complete.
\begin{longanswer}
\begin{verbatim}
sort stack imports bool, element
operations:
   new:   stack
   push:  element × stack -> stack
   pop:   stack -> stack
   top:   stack -> element
   empty: stack -> bool
variables:
   s: stack, e: element
axioms:
   pop(push(e,s)) = s
   top(push(e,s)) = e
   empty(new()) = true
   empty(push(e,s)) = false
\end{verbatim}
new, push are the two generators.
\end{longanswer}
\end{question}

Now turn to the Java class \textsf{Stack}. As it is easy to see,
this class is not an implementation of your algebraic specification 
in part 1---its signature and semantics simply differ. 

\begin{enumerate}
%    \item First of all, top is called peek.
    \item In Java, semantics are defined in all cases. Java never gets stuck,
    but returns an exception.
    \item pop returns a value in addition to modifying the stack.
    \item search is an additional operation.
\end{enumerate}


The goal of the following exercises is to adjust your algebraic specification
from 1. so that \textsf{java.util.Stack} can be considered a reasonable
implementation. 

\begin{question}{1}
Provide axioms that reflect better the behaviour of Java in case exceptions.
Consider \textsf{error} as a member of all sorts, which you can use to
represent a raised exception. 
\end{question}

\begin{question}{1}
Make the change to the stack in \textsf{pop} explicit by changing it to return
a pair of result and updated stack. Adapt the axioms.
\end{question}

\begin{question}{1}
Add signature and axioms for search. You can assume the semantics for integers.


\begin{longanswer}
\begin{verbatim}
sort Stack imports Vector, E, Object, boolean, int, EmptyStackException
operations:
   new:   Stack
   push:  Stack × E -> Stack

   pop:   Stack -> Stack × E
   peek:  Stack -> E
   empty: Stack -> Stack × boolean
   search: Stack × Object -> Stack × int
variables:
   s: Stack, e: element, o: Object, error: EmptyStackException
axioms:
   pop(push(s,e)) = (s,e)
   pop(new) = error

   peek(push(s,e)) = e
   peek(new) = error

   empty(push(s,e)) = false 
   empty(new) = true

   search(new,o) = -1
   search(push(s,o),o) = 1
   search(push(s,e),o) =
     if search(s,o) == -1
       then -1
       else 1 + search(s,o)

   ---

   has(new,o) = false
   has(push(s,o),o) = true
   has(push(s,e),o) = has(s,o)

   searchAccDepth(new,o,d) = -1
   searchAccDepth(push(s,o),o,d) = d
   searchAccDepth(push(s,e),o,d) = searchAccDepth(s,o,d+1)

   search(s,o) = searchAccDepth(s,o,1)


\end{verbatim}
\end{longanswer}
\end{question}

Further material:
\begin{itemize}
\item The Java API:
\url{http://java.sun.com/j2se/1.5.0/docs/api/java/util/Stack.html}
\item Auxiliary lecture notes:
\url{http://www.cs.st-andrews.ac.uk/~ifs/Resources/Notes/FormalSpec/AlgebraicSpec.pdf}
\end{itemize}





\newpage
\section{A Glimpse of Squeak \percent{4}}

\begin{question}{1}
For each of the following expressions determine
the message(s), and for each message determine the receiver object and all 
argument object(s). 
\begin{java}
Date today 
2 + 3 
anArray at: 1 put: 'hej'
10 raisedTo: 2 + 3
10 negated raisedTo: 2 + 3
2 * 3 + 4      
\end{java}
\answer{
\begin{tabular}[t]{l|lll}
           & Mesg & Receiver               & Args  \\ \hline
Date today & today & Date                  & none   \\
2 + 3      & +     & 2                        & 3   \\
anArray at: 1 put: 'hej' & at:put: & anArray & 1, 'hej'  \\
10 raisedTo: 2 + 3       & +           & 2  & 3 \\
                         & raisedTo:    & 10 & 5  \\
10 negated raisedTo: 2 + 3 & negated   & 10 & none \\
                           & raisedTo:  & -10 & 5 \\
                           & +         & 2   & 3 \\
2 * 3 + 4                  & *         & 2   & 3 \\
                           & +         & 6   & 4 \\
\end{tabular}
}
\end{question}

\begin{question}{1}
The following snippet contains a fragment of the class
\textsf{Count} with the methods \textsf{initialize},
 \textsf{value},  \textsf{increment1}, and \textsf{increment2}:

\begin{java}
initialize
    value := 0.
value
    value notNil ifFalse: [^0].
    ^value
increment1
    value := value + 1.
increment2
    value := self value + 1
\end{java}

Explain the difference between the two increment methods.
What are the benefits of the \textsf{increment2} version?
\answer{
Note the overloading of ``value'': increment1 uses the instance
variable ``value'' directly, while increment2 sends the ``value'' message
to ``self.'' Thus, increment1
establishes a direct dependence on the implementation of the class, which
could be considered a disadvantage from a maintenance point of view. 
}
\end{question}

\begin{question}{1}
What is the meaning of the semicolon (``;''), thus the value
of \textsf{aCounter} at the end of  the following program (1 sentence)?

\begin{java}
|aCounter|
aCounter := Count new.
aCounter initialize.
aCounter increment1; increment2.
\end{java}
\answer{
    The semicolon means ``cascading'', which means that \textsf{increment1}
    and \textsf{increment2} are sent to the same target. Thus, the counter
    obtains the value ``2.''
}
\end{question}

\paragraph{Hint}
open the ``Browser'', implement the class \textsf{Count}, enter the
 program below in 
the ``Workspace'',
run the program, and ``inspect'' the counter variable.

\begin{question}{1}
Consider the following block expression:
\begin{java}
|anArray sum|
sum := 0
anArray := #(4 55 19 23).
anArray do: [:item | sum := sum + item].
^sum
\end{java}

Rewrite the block using \textsf{inject:into}.

\begin{longanswer}
The resulting block looks something like this:
\begin{java}
|xs sum|
sum := xs inject: 0 into: [:a :x | a + x]
^sum
\end{java}

Note the similarity to the formulation of sum using reduce from the Haskell exercises:
\begin{verbatim}
sum xs = reduce (\a x -> a + x) 0 xs
\end{verbatim}
\end{longanswer}
\end{question}

\paragraph{Hint}
You might want to rewrite the summation in Java (or a Java-like language)
as a sanity check.

\noindent Further material
\begin{itemize}
\item By default, Squeak is not installed on the machines in the department,
but you can easily install it yourself at home or in your account at
Chalmers. Visit the download area on the main webpage of Squeak:

\url{http://www.squeak.org}

\item The Squeak main page contains links to tutorials of varying degree
of difficulty and lots of other useful online resources. Here is a 
tutorial for Java programmers:

\url{http://daitanmarks.sourceforge.net/or/squeak/squeak\_tutorial.html}

\end{itemize}
\end{document}

