\documentclass{article}
\usepackage{fancyvrb,hyperref,listings,verbatim}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}
\newcommand{\jp}[1]{ \footnote{#1}}

\lstset{commentstyle=\textit,flexiblecolumns=true,mathescape=true}
\lstnewenvironment{prolog}
    {\lstset{language=prolog,frame=tb}}
    {}

\newcommand{\courseinfo}{ JP Bernardy \and Gustav Munkby}
\newcommand{\percent}[1]{\protect \marginpar[l]{\bf [#1 points]}}
\newcommand{\mycomment}[1]{}

\newcounter{question}
\newenvironment{question}[1]{%
  \addtocounter{question}{1}%
  \paragraph{Exercise~\arabic{question}  }%
}{%
  \vskip1em%
}

\let\longanswer=\comment
\let\endlonganswer=\endcomment
\newcommand{\answer}[1]{}

% Uncomment to show answers
 \renewenvironment{longanswer}{\paragraph{Answer~\arabic{question}}\ }{}
 \renewcommand{\answer}[1]{\begin{longanswer}#1\end{longanswer}}
  

\begin{document}
\title{Ex. 6: Programming Paradigms 
\\
Logic Oriented Programming --- Exercises}
\author{\courseinfo}
\date{Programming Paradigms 2008}
\maketitle

\section{Prolog}
We advise you to use SWI-Prolog to test your solutions.
You can find it here:
\url{http://www.swi-prolog.org/}
This page will help you getting started:
\url{http://gollem.science.uva.nl/SWI-Prolog/Manual/quickstart.html}

Also, we found that version 5.6.47 was buggy, but 5.6.55 was ok.

\textbf{Note.} SWI prolog comes with the "cyclic unification" feature
activated. You should switch it off by setting the \texttt{occurs\_check} flag to \texttt{true}, by issuing on the interpreter the command
\begin{prolog}
set_prolog_flag(occurs_check,true).
\end{prolog}

\section{Unification}

\begin{question}{2}
What is the result of the following unifications? 
Try to come up with the result without using the prolog interpreter!

\begin{tabular}{c}
a(X,Y) = a(b,c) \\
a(X,Y) = a(Z,Z) \\
a(X,X) = a(b,c) \\
a(X) = a(b,b) \\
a(X,X,Y) = a(Z,W,W) \\
\end{tabular}

\begin{longanswer}

\begin{tabular}{c}
X = b, Y = c \\
X = Y = Z \\
fail \\
fail \\
X = Y = Z = W \\
\end{tabular}
    
\end{longanswer}

\end{question}



\section{Reversibility}


Consider a predicate \textsf{split/3}, that splits a list of integers into two lists: one containing the positive ones (and zero), the other containing the negative ones.

\begin{verbatim}
split([3,4,-5,-1,0,4,-9],P,N)
\end{verbatim}

should return:

\begin{verbatim}
P = [3,4,0,4]
N = [-5,-1,-9].
\end{verbatim}


\begin{question}{1}
    Write the predicate \textsf{split/3}. Make sure that it is \emph{reversible}. That is,
    you can recover the original list if you pass it the split lists.
\begin{longanswer}\ 
\begin{prolog}
split([],[],[]).
split([X|A],[X|P],N) :- X >= 0, split(A,P,N).
split([X|A],P,[X|N]) :- X <  0, split(A,P,N).
\end{prolog}
\end{longanswer}
\end{question}    

\begin{question}{1}
    What are the lists that are returned by \textsf{split/3} when used in reverse?
\answer{All the possible interleavings of the inputs. If a number of the wrong class is
in either of the inputs, it will fail.}
\end{question}


\section{Cut}

\begin{question}{1}
    Explain what the following program does:

\begin{prolog}
        class(Number,positive) :- Number > 0.
        class(0,zero).
        class(Number, negative) :- Number < 0.
\end{prolog}
\answer{
\textsf{class(N,C)} relates number with their class, positive, negative or otherwise.
}
\end{question}

\begin{question}{1}
  Improve the previous program by adding green cuts.
\begin{longanswer}\ 
\begin{prolog}
        class(Number,positive) :- Number > 0, !.
        class(0,zero) :- !.
        class(Number, negative) :- Number < 0, !.
\end{prolog}
\end{longanswer}
\end{question}

\begin{question}{1}
  ``Optimize'' the above program. (Transform some green cuts into red cuts).
\begin{longanswer}\ 
\begin{prolog}
        class(Number,positive) :- Number > 0, !.
        class(0,zero) :- !.
        class(Number, negative) :- !.
\end{prolog}
\end{longanswer}
\end{question}


\begin{question}{1}
  Improve the predicate \textsf{split/3} by adding cuts. Don't worry about reversibility now.

\begin{longanswer}\ 
\begin{prolog}
split([],[],[]) :- !.
split([X|A],[X|P],N)  :-  X  >=  0,  !, split(A,P,N).
split([X|A],P,[X|N])  :-  X  <   0,  !, split(A,P,N).
\end{prolog}
\end{longanswer}

\end{question}

\begin{question}{1}
  What if you try to use your new split/3 in reverse?

\answer{
  It still works OK, as long as no condition has been removed.      
}
\end{question}

\section{Negation}

You can express the negation of an expression by using cut and failure:

\begin{prolog}
neg(Goal) :- Goal,!,fail.
neg(Goal).
\end{prolog}


We want to define a predicate that will tell us which students like which
programming paradigm. Let's say Sven likes all programming languages \emph{except}
prolog.
We could model this as such:

\begin{prolog}
like(sven,haskell).
like(sven,java).
like(sven,fortress).
like(sven,erlang).
...
\end{prolog}

That is fine as long as we can enumerate all languages: we can just leave prolog out.
(But it is also very tedious). 


\begin{question}{1}
With the help of the \textsf{neg} predicate,
can you express the same idea using just one clause?

\begin{longanswer}
\begin{prolog}
like(sven,Language) :- neg(Language = prolog).
\end{prolog}
\end{longanswer}
\end{question}

\begin{question}{1}
This new predicate is not reversible. Why?

\answer{Reversible here means that you can basically consider the predicate a device in which each of the arguments can act as inputs or outputs. Suppose you want to know which languages does sven like with like(sven,X). You will get false because of how the neg predicate is built.
Note that an unification that succeeds is always true.}

\end{question}

\textsf{elem} can be used to test if an element belongs to a list:

\begin{prolog}
elem(X,[X|Xs]).                                                                                 elem(X,[Y|Xs]) :- elem(X,Xs).                                                                  
\end{prolog}


\begin{question}{1} 

Using \textsf{neg} and \textsf{elem}, write a predicate \textsf{diff(A,B,C)}
such that \textsf{C} is a list that contains all the elements in list \textsf{A}
that are not elements in list \textsf{B}.

\begin{longanswer}
\begin{prolog}
diff([],Ys,[]).                                                                          
diff([X|Xs],Ys,Zs)     :- elem(X,Ys),       diff(Xs,Ys,Zs).
diff([X|Xs],Ys,[X|Zs]) :- neg(elem(X,Ys)),  diff(Xs,Ys,Zs).                                 
\end{prolog}
\end{longanswer}
\end{question}


\section{Applying Unification}

A difference list is a special structure that can support efficient
concatenation (Recall the discussion on \texttt{append/3} predicate in the lectures). It uses unification in a clever way to that end.

The difference-list representation for a list can be obtained as follows:

\begin{prolog}
fromList([],d(X,X)).
fromList([A|As],d(A:Out,In)) :- fromList(As,d(Out,In)).
\end{prolog}


A structure of the form \textsf{d(Out,In)} will represent the list 
\textsf{L} if \textsf{Out} unifies with \textsf{L} concatenated with \textsf{In}. Or, less technically, a list L will be represented as the
difference between Out and In: so for instance,

$$[1,2] \longrightarrow d(1:2:3:4:[],3:4:[])$$

You can check how fromList works by testing it: 
\begin{prolog}
fromList([1,2,3],X).
\end{prolog}

Note that the same metavariable (G271 in my implementation) is present twice in
the result. Note that we can get the original result back by unifying this
metavariable with the empty list.

\begin{question}{1}
Write a predicate toList/2 to get back to the normal list representation.
\begin{longanswer}
\begin{prolog}
toList(d(X,X),[]).
toList(d(Head:Rest,Tail),[Head|OtherTail]):- toList(d(Rest,Tail),OtherTail).
\end{prolog}
\end{longanswer}

\end{question}

Given that representation for lists, it is possible to perform concatenation by
doing unification only!

\begin{question}{1}
Write a predicate dconcat/3 to concatenate two difference lists, without
using the direct representation.

\begin{prolog}
dconcat(X,Y,Z), fromList([1,2,3],X), fromList([4,5],Y), toList(Z, Final).
\end{prolog}


should produce:

\begin{verbatim}
Final = [1,2,3,4,5].
\end{verbatim}

\begin{longanswer}
\begin{prolog}
dconcat(d(Out2,In2),d(Out1,In1),d(Out,In)) :- Out = Out2, In2 = Out1, In = In1.
\end{prolog}

or

\begin{prolog}
dconcat(d(Out,Intermediate),d(Intermediate,In),d(Out,In)).
\end{prolog}

\end{longanswer}


\end{question}

\end{document}
\begin{question}{1}
What happens when you concatenate a difference list with itself?
\answer{The difference list will contain circular, infinite lists.}
\end{question}



