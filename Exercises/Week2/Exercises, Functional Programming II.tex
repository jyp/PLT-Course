\documentclass{article}
\newcommand{\percents}[1]{\protect \marginpar[l]{\bf [#1 points]}}
\newcounter{question}
\newcommand{\question}[2]{
  \addtocounter{question}{1}
  \paragraph{Exercise~\arabic{question}  \percents{#1}}
   #2
  \vfil
 }

\begin{document}

\title{Exercises on Functional Programming II\\
  \large Programming Paradigms}
\author{John Hughes}
\maketitle

\newcommand{\answer}[1]{} %{\begin{quote}{\bf Answer:} #1\end{quote}}
\newcommand{\percent}[1]{} %{\marginpar{\bf Value: #1\%}}
\section{Extending the Calculator}
\percent{20}
In this section, you will extend both the calculator application and
the parsing library. The code written in the lecture has been tidied
up, separated into two modules (\verb!ParserLibrary! and
\verb!Calculator!), and uploaded to the course home page.

Now that the code written in the lecture has been divided into a
library and an application, of course none of the code in the
application (\verb!Calculator.hs!) should depend on the {\em
  representation} of parsers. We should be able to replace the type of
parsers by an abstract type, without modifying any of the code in the
application. However, the definition of \verb!digit! {\em does} depend
on the representation type. 

\question{1}{What is the representation of a parser from the parser
library? Give the type and explain its meaning.}

\question{1}{List the operations (functions) that depend on the parser
representation (in \texttt{ParserLibrary.hs}).
In other words, which functions will have to be changed if the representation
changes?}

\question{1}{
Rewrite the definition of \texttt{digit} so that it does not depend
on the parser representation, i.e. it should use only \texttt{digitval}
and operations exported from \texttt{ParserLibrary.hs}.
}

\question{1}{
The simple calculator function we developed only supports two
arithmetic operations: addition and multiplication. Extend the
calculator code so that it also handles exponentiation: \texttt{2\^{}3}. (Use the
standard operator \texttt{\^{}} for the semantics)
  }

\question{1}{
The parser developed in the lecture only allows a {\em single}
addition in an expression: ``1+2'' is allowed, but not
``1+2+3''. Extend the parser to allow any number of multiplications, additions and
exponentiations.
}


\question{1} {
What is the associativity of the the exponent operator you provided?
(You can test it by parsing and calculating ``\texttt{3\^{}3\^{}3}'')}


\question{1} {
Explain why your parser behaves like this.
}

\question{0} { Add support for subtraction, with left associativity. Can you
write a generic library function for supporting left-associative functions?
(Advanced question)}


\paragraph{Note:} The parser developed in the lecture does not accept white space in the
strings it parses. 

\question{1} {
Extend the parsing library with an operation
\texttt{white p}, which ignores white space and then parses a
\texttt{p}. (You will find the standard function \texttt{isSpace},
exported by in module \texttt{Char}, useful for recognising white-space
characters). Note that the function \texttt{white} transforms a parser
into another parser. i.e. it has \emph{type} \texttt{white :: Parser a -> Parser a}
}

\question{1} {
Make use of the new operation to modify the calculator so
that white space is accepted between any pair of symbols.
\percent{4}
}

\paragraph{Note:}
The \texttt{many p} function developed in the lecture parses any number
of \texttt{p}s---but may happily parse zero \texttt{p}s, even if several
are present. For example, the \texttt{number} parser (which uses
\texttt{some digit}) can parse the input ``123'' either as 123, or as 12
followed by ``3'', or as 1 followed by ``23''. Usually, the {\em
longest} possible parse is the one we want. Thus we might like to
insist that after parsing \texttt{many p}, then \texttt{p} {\em must fail}
on the remaining input!

\question{1} { Define a parser \texttt{fails p} that succeeds {\em only} if
\texttt{p} fails when presented with the same input. \texttt{fails p} should not
consume any input though. }

\question{1} {
Use it to define a version of \texttt{many}
that always parses the {\em longest} possible sequence of \texttt{p}s.
}


\paragraph{Note:} This parsing library illustrates some fundamental
principles of functional programming, but is far from ``production
quality'' code. Not only is the interface it provides rather minimal,
it suffers also from severe inefficiencies, and produces appalling
diagnostics when it encounters a syntax error---parsing libraries
have, in fact, been the subject of many research papers, which have
shown how to develop libraries with a similar interface, but very good
performance and usability. A widely used library today is
called Parsec. You can read about it here
\begin{quote}
\texttt{http://legacy.cs.uu.nl/daan/parsec.html}
\end{quote}
but this is not necessary to solve this exercise.


\section{LISP S-Expressions}
LISP S-expressions can be represented in Haskell by the following
type:
\begin{verbatim}
data SExp = Numb Int | Atom String | Cons SExp SExp
  deriving (Show,Eq)
\end{verbatim}
This declares a new type \texttt{SExp} with three constructors,
\texttt{Numb}, \verb!Atom!, and \verb!Cons!, with arguments of the types
given. The ``deriving'' clause instructs the compiler to generate code
to display \verb!SExp! values (convert them to strings), and compare
them for equality using \verb!==!.

The code to get started with this exercise is provided in the file \texttt{Lisp.hs}.

\begin{enumerate}
\item
The default way of displaying values of this type is rather ugly,
however. S-expressions are displayed as the Haskell source code that
constructs them, so for example:
\begin{verbatim}
Lisp> Cons (Numb 1) (Cons (Numb 2) (Atom "nil"))
Cons (Numb 1) (Cons (Numb 2) (Atom "nil"))
\end{verbatim}
A LISP interpreter would display the corresponding value as
``\verb!(1 2)!''. We defined a Haskell function \verb!string! which
converts a Haskell \verb!SExp! to the string that a LISP system would
print for it. For example,
\begin{verbatim}
Lisp> string (Cons (Numb 1) (Cons (Numb 2) (Atom "nil")))
"(1 2)"
\end{verbatim}
\question{0}{Read the function and understand it.}
\item
A LISP interpreter also contains parsing functions to convert strings
such as ``(1 2)'' into the corresponding internal representation. Use
the parsing library developed in the lecture---with the improvements
you made above---to write a parser for S-expressions. For example,
\begin{verbatim}
Lisp> parse sexp "(1 2)"
[Cons (Numb 1) (Cons (Numb 2) (Atom "nil"))]
\end{verbatim}

\question{1}{Write a parser for LISP atoms.}
\question{1}{Write a parser for (possibly negative) numbers.}
\question{3}{Write a parser for SExpressions using the above two parsers.}

You will need to test your code, and you can use the ``printer''
(\verb!string!) to test your parser. 

The provided \verb!Lisp.hs! uses Haskell's test tool QuickCheck to
test that converting any S-expression to a string, and back again,
results in the same data-structure. 

If you start with the \verb!Lisp.lhs! file, you can you can then test your code
using:
\begin{verbatim}
Lisp> quickCheck prop_sexp_string
OK, passed 100 tests.
\end{verbatim}
If you see the output above, repeatedly, then your code probably works!
\end{enumerate}

\vfill

\end{document}