\documentclass{article}


\usepackage[latin1]{inputenc}
\usepackage{fancyvrb}
\usepackage{pstricks,pst-node,pst-text,pst-3d, pst-tree}
\usepackage{hyperref}
\usepackage{graphicx}
%\pagestyle{fancy}
%\lhead{S. Schupp} %}

%\oddsidemargin 0.35in
%\textwidth 5.0in
%\textheight 9.5in
%\topmargin -0.5in

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}
\newcommand{\cpp}{\Cpp}


\usepackage{listings}
\lstset{language=java,basicstyle=\small}
\lstset{commentstyle=\textit,flexiblecolumns=true,mathescape=true}
\lstnewenvironment{java}
    {\lstset{language=java,frame=tb}}
    {}
\lstnewenvironment{java2}
    {\lstset{language=java}}
    {}
\lstnewenvironment{cplus}
    {\lstset{language=c++,frame=tb}}
    {}
\lstnewenvironment{cplus2}
    {\lstset{language=c++}}
    {}
\lstnewenvironment{perl}
    {\lstset{language=perl,mathescape=false,lineskip=0\baselineskip}}
    {}


\lstdefinelanguage{FSharp}
      {morekeywords={let, new, match, with, rec, open, module,
           namespace, type, of, member, and, for, in, do,  
           begin, end, fun, function, try, mutable, if, then, else, class, end},
    keywordstyle=\color{blue},
    sensitive=false,
    morecomment=[l][\color{green!50!black!80}]{///},
    morecomment=[l][\color{green!50!black!80}]{//},
    morecomment=[s][\color{green!50!black!80}]{{(*}{*)}},
    morestring=[b]",
    stringstyle=\color{red},
    columns=fullflexible
}

\begin{document}
\title{Exercises 5: Object-Oriented Programming}
\date{}

\maketitle

\section{Parameter Passing}

\begin{java}
function g(by-?? x:int, by-?? y:int) {
   x = x - y;
   y = x + y;
   x = y - x;
}

function h1() {
  x = 10;
  y = 5;
  g(x,y);
}

function h2() {
  x = 10;
  g(x,x);
}

\end{java}


\begin{enumerate}
  \item What are the values of \texttt{x} and \texttt{y} in
    \texttt{h1} directly after \texttt{g} finished execution and
    returned, when parameters are (i) passed by value-result and (ii)
    passed by reference?
  \item What are the values of \texttt{x} and \texttt{y} in
    \texttt{h2} directly after \texttt{g} finished execution and
    returned, when parameters are (i) passed by value-result and (ii)
    passed by reference?
\end{enumerate}

\section{Co-, Contra-, Nonvariance}

\begin{java}
interface Monoid {
   Monoid op(Monoid second);
   Monoid id();
};

struct IntegerAdditiveMonoid : Monoid {
    public IntegerAdditiveMonoid(int x) { 
         elt = x;
    }    
    public IntegerAdditiveMonoid op(IntegerAdditiveMonoid second) { 
         return new IntegerAdditiveMonoid(
             elt + second.elt); 
    }
    public IntegerAdditiveMonoid id(){ 
         return new IntegerAdditiveMonoid(0);
    }
    int elt;
};

> gmcs Monoids.cs 
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement 
  interface member `Monoid.op(Monoid)'
Monoids.cs(2,11): (Location of the symbol related to previous error)
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement 
  interface member `Monoid.id()'
Monoids.cs(3,11): (Location of the symbol related to previous error)
Compilation failed: 2 error(s), 0 warnings

\end{java}
%
Your task:
\begin{enumerate}
\item Briefly recap: what is a \textit{monoid}, mathematically? Give two examples
of data types that can be considered monoids.
\item The C\#-code above does not compile. Explain the error message
in terms of co-/contra-/nonvariance.
\item What if the method \textsf{op} \textit{would} compile? 
Introduce instances \textsf{a,b} of appropriate types so that
\textsf{a.op(b)}, if compiled, would result in a run-time error.
What if the method 
\textsf{id} would compile? Could you construct a similar run-time
error? 
\item The corresponding program in Java behaves differently. Briefly
explain how, consult the Java Language Specification (JLS), and back your answer
with the appropriate clause(s) in the JLS.
\item Suppose you changed the code so that 
the (current) C\#-compiler accepts it. What is the problem then? 
\end{enumerate}

\paragraph{Further reading}
\begin{itemize}

\item The Mono compiler is a free compiler for C\#. Read more about it
at

\textsf{http://www.mono-project.com/CSharp\_Compiler}

\item JLS is available on-line 
 at 
\url{http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html}

\end{itemize}

\newpage
\section{Dynamic dispatching \& the visitor [25 points]}

Suppose the three classes \textsf{Shape}, \textsf{Rectangle}, and 
\textsf{Circle}, and the appropriate inheritance relation between them.
Further assume a method \textsf{intersect()} that can determine whether two
shapes overlap. Obviously, the implementation of \textsf{intersect()} 
depends on the actual shapes involved. 

\begin{enumerate}
\item Implement  and design  the 3 classes so that all possible
  intersections of shapes can be properly handled using Smalltalk.
  What is the problem with single dispatching? Name at least 2 issues.
\item The following Java snippet redesigns the
  class hierarchy using \textit{double dispatch}. 
  Explain how double dispatching works by
  giving the sequence of calls for the line marked (*) in \textsf{Main}.
  Name two problems with double dispatching.
  
\begin{java}
class Shape {
    public  boolean intersect(Shape s) {
         return s.intersectShape(this);
    }
    protected  boolean intersectShape(Shape s) {
        // intersect Shape x Shape
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // no special code for Shape x Rectangle
        return intersectShape(r);
    }
    protected  boolean intersectCircle(Circle c) {
        return intersectShape(c);
   }
}
class Rectangle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectRectangle(this);  
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // Rectangle x Rectangle
        ..
    }
}
class Circle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectCircle(this);  
    }
    protected  boolean intersectCircle(Circle c) {
        // Circle x Circle 
   }   
}

class Intersect {
   public static void Main() {
      Shape s1 = new Rectangle(); 
      Shape s2 = new Circle();
      boolean b = s2.intersect(s1);        // *
   }
}
\end{java}

\item The \textit{Visitor pattern} provides an alternative workaround,
also based on double dispatching. In difference
to the solution above, the pattern 
introduces two hierarchies, the visited
hierarchy and the visitor hierarchy. In the example,
 \textsf{Shape, Rectangle, Circle}
form the visited hierarchy, \textsf{IntersectVisitor} and its two
subclasses \textsf{RectangleIntersectVisitor} and \textsf{CircleIntersectVisitor}
form the visiting hierarchy. The visited classes are
augmented with a method \textsf{accept}, which uses double dispatching
to call the appropriate ShapeVisitor (and to invoke the
right computation). 
\\
Your task
\begin{itemize}
\item Complete the code for the two class hierarchies and the client.
\item Name two problems of the visitor approach.
\end{itemize}

\begin{java2}
class Shape {
    public void accept(IntersectVisitor v) {
	v.visitShape(this);
    }
}
class Rectangle extends Shape {
public  void accept(IntersectVisitor v) { 
        // your job
    }
}
class Circle extends Shape {
   // your job
}
 
// visitor hierarchy
abstract class IntersectVisitor { 
    boolean intersects; 
    public abstract void visitShape(Shape s);
    public abstract void visitRectangle(Rectangle r); 
    public abstract void visitCircle(Circle c); 
} 

// client code
  Shape s1 = new ..
  IntersectVisitor v = new RectangleIntersectVisitor();
  s1.accept(v);
  if (v.intersects) ...
\end{java2}
\end{enumerate}

\paragraph{Further reading}
\begin{itemize}
\item MultiJava is a research language that implements multi-method:\\
\textsf{http://www.cs.washington.edu/research/projects/cecil/pubs/mj-toplas.pdf}
\item An alternative to multi-methods that also avoids the problems of
single- or double dispatch, are ``open methods.'' A
 proposal exists to extend the \Cpp\ language by ``open methods'', see
document no N2216=07-0076 by the standardization committee:

\textsf{www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2216.pdf}
\end{itemize}

\newpage
\section{F\#: Multi-Paradigms}

\subsection{Functional Paradigm}

Red-black trees are self balancing binary search trees. Typical
descriptions of the algorithm are targeted towards imperative or
object-oriented settings. 

Okasaki describes how to implement them in a purely functional
manner. The description is available at:

\url{http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps}


The F\# language reference at
\url{http://msdn.microsoft.com/en-us/library/dd233181.aspx} provides
useful information about F\# functions, pattern matching, asynchronous
workflows etc.\ for this exercise.


\begin{enumerate}
\item Implement Okasaki's red-black tree using F\#. To keep it
  simple, assume that only \texttt{int}'s are stored in the
  tree. Extend therefore the F\# code found in \texttt{RedBlack.fs}

\item Test your implementation by creating red-black trees containing
  \begin{itemize}
    \item all elements from 1 to 4 
    \item all elements from 1 to 100 
    \item all elements from 1 to 10000
 \end{itemize}

\item Implement one function each for computing:
  \begin{itemize}
    \item the tree's depth
    \item the tree's size
    \item the sum of all elements stored in the tree
  \end{itemize}
  and test your functions using the trees from the previous item.

\item (Optional:) Asynchronous workflows provide an elegant mean to
  make use of multi-core processors and do work in parallel. Implement
  an asynchronous function \texttt{computeAll} which runs the
  previously functions (depth, size and sum) in parallel.
\end{enumerate}


\subsection{Object-Oriented Paradigm}

We want now to implement a set type backed by the red-black tree. The
set should be also usable from other languages of the \texttt{.net}
framework, e.g., C\#. Therefore the implementation should be done
using classes. 

\begin{enumerate}
  \item Implement a class ImmutableIntSet which is backed by a
    red-black tree. Provide the following methods:
    \begin{itemize}
      \item \texttt{Add}: which takes an \texttt{int} and returns a
        new ImmutableIntSet instance containing the given integer and
        all previous elements
      \item \texttt{HasElement}: which takes an \texttt{int} and
        checks if the given integer is in the set
      \item \texttt{Size}: returning the size of the set 
   \end{itemize}
  \item Implement a class MutableIntSet which should also be backed by a
    red-black tree. But this time the \texttt{Add} method shall not
    return a new set, but change the content of the set object itself
    to include the new element.
\end{enumerate}


\subsection{Mutability}

\begin{enumerate}
\item Which of the expressions labelled \texttt{(* a<nr> *)} is a
  valid/legal expression?
\begin{lstlisting}[language=FSharp]
let x = 7
let mutable xMut = 7
let xRef = ref 7

x <- 10  (* a1 *)
x := 10   (* a2 *)

xRef := 10  (* a3 *)
XMut <- 10  (* a4 *)

let y = x   (* a5 *)
let y = !xMut (* a6 *)
let y = !xRef (* a7 *)
\end{lstlisting}


\item The questions are inlined as comments labelled \texttt{(* b<nr> *)} 
\begin{lstlisting}[language=FSharp]
let x = 7
let mutable xMut = 7
let xRef = ref 7

let divide x y = x / y
let divideRef x y = 
    y := divide x !y
    !y
let divideImp x (y:int byref) = 
    y <- divide x y
    y

(* (b1) Is the expression below legal? If yes, what is the value of res1, x, xMut, xRef afterwards? *)
let res1 = divide 42 7

(* (b2) Is the expression below legal? If yes, what is the value of res2, x, xMut, xRef afterwards? *)
let res2 = divide 42 x

(* (b3) Is the expression below legal? If yes, what is the value of res3, x, xMut, xRef afterwards? *)
let res3 = divideRef 42 x

(* (b4) Is the expression below legal? If yes, what is the value of res4, x, xMut, xRef afterwards? *)
let res4 = divideRef 42 (ref 7)

(* (b5) Is the expression below legal? If yes, what is the value of res5, x, xMut, xRef afterwards? *)
let res5 = divideRef 42 xRef

(* (b6) Is the expression below legal? If yes, what is the value of res6, x, xMut, xRef afterwards? *)
let res6 = divideImp 42 &xMut
\end{lstlisting}
\end{enumerate}

\end{document}

\section*{Answers (sketches)}

\section{Parameter Passing}

1. swaps values in x and y in both cases
2. x is 10 in by value-result; but x is 0 using by reference


\section*{Co/contra/nonvariance}
%http://archives.cs.iastate.edu/documents/disk0/00/00/02/53/00000253-00/tr01-10.pdf
%http://ece.colorado.edu/~siek/pubs/pubs/2005/siek05\_thesis.pdf
%http://c2.com/cgi/wiki?LanguageTypeErrors
%Java generics
\begin{enumerate}
\item The set of strings form a monoid under 
concatenation, with the empty string as identity. 
Other monoids (int,+,0), (int,*,1), (float, +,0), (list, append, emptyList),
\ldots 
\item Error: C\# requires invariance both for argument types and for
the return types. That's why we get an error for each method.

\item If C\# would allow covariance in the argument type,  one
could substitute siblings for another and that way cause a run-time
error. In the example below, the method
a.op() expects an IntegerAdditiveMonoid, but gets a RealAdditiveMonoid.
\begin{java}
struct RealAdditiveMonoid: Monoid  {
    public RealAdditiveMonoid(double x) {
         elt = x;
    }
    public RealAdditiveMonoid op(Monoid second) {
         return new RealAdditiveMonoid(
             elt + ((RealAdditiveMonoid)second).elt);
    }
    public RealAdditiveMonoid id(){
         return new RealAdditiveMonoid(0.0);
    }
    double elt;
};


class Main {
   public static void main(string[] args) {
      Monoid a = new IntegerAdditiveMonoid(7);
      Monoid b = new RealAdditiveMonoid(2.3);
      b = a.op(b);
   }
}

\end{java}
\item Java is covariant in the return type (JLS, 8,4,8.3). Therefore,
Java would only flag an error for the method op() (since it doesn't implement
the interface); the method id(), on the other hand, would be considered
an implementation. 
\item The typical workaround: use the requested signature, but then
cast the argument to the desired type (IntegerAdditiveMonoid),
and from there back to Monoid. Obviously, the first cast isn't safe. 
\begin{java}
    public Monoid op(Monoid second) { 
         return new IntegerAdditiveMonoid(
              elt + ((IntegerAdditiveMonoid)second).elt);
    }

    public Monoid id(){ 
         return new IntegerAdditiveMonoid(0);
    }
    int elt;
\end{java}
\end{enumerate}

\section*{Dispatch}
%http://www.disi.unige.it/person/ZuccaE/Didattica/Dottorato02/MultiJavaSlides.pdf
%http://www.itu.dk/courses/VOP/F2006/4_Slides.pdf
%http://blogs.msdn.com/devdev/archive/2005/08/29/457798.aspx
\begin{enumerate}
\item Problems of single dispatch: 1. Extensibility (if a new class is
derived from Shape, Rectangle and Circle have to change their implementation).
2. Run-time overhead due to type cast 3. Loss of static type safety
\begin{java}
class Shape {
    public boolean intersect(Shape s) {
        // intersect Shape x Shape
        return false;
    }
}
class Rectangle extends Shape {
    public  boolean intersect(Shape s) {
        if (s instanceof Rectangle) {
           // intersect Rectangle x Rectangle
        }
        else {
	    // intersect Rectangle x Shape
             return super.intersect(s);
        }
        return false;
    }
}
class Circle extends Shape {
   public boolean intersect(Shape s) {
         if (s instanceof Circle) {
           // intersect Circle x Circle
        }
        else {
             return super.intersect(s);
        }
	 return false;
    }
}
\end{java}
\item Problems with  double dispatch: 1.  Root class needs to be modified
each time a new class is added; 2. lots of code to write


\begin{java}
class Shape {
    public  boolean intersect(Shape s) {
         return s.intersectShape(this);
    }
    protected  boolean intersectShape(Shape s) {
        // intersect Shape x Shape
        return true;
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // no special code for Shape x Rectangle
        return intersectShape(r);
    }
    protected  boolean intersectCircle(Circle c) {
        return intersectShape(c);
   }
}
class Rectangle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectRectangle(this);  
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // specialized code for two rectangles
        return false; 
    }
}
class Circle extends Shape { 
    public  boolean intersect(Shape s) {
        return s.intersectCircle(this);  
    }
    protected  boolean intersectCircle(Circle c) {
        return false;
   }      
  
}
\end{java}
\item Problems with the visitor: 1. Needs to be anticipated at class
design time (of Shape). 2. Doesn't work so smoothly if one has to pass
additional parameters.
\begin{java}
class Shape {
    public void accept(IntersectVisitor v) {
	v.visitShape(this);
    }
}
class Rectangle extends Shape {
    public  void accept(IntersectVisitor v) { 
      v.visitRectangle(this);
    }
}
class Circle extends Shape {
    public  void accept(IntersectVisitor v) { 
      v.visitCircle(this); } 
}
 
// visitor hierarchy
abstract class IntersectVisitor { 
    boolean intersects; 
    public abstract void visitShape(Shape s);
    public abstract void visitRectangle(Rectangle r); 
    public abstract void visitCircle(Circle c); 
} 
class RectangleIntersectVisitor extends IntersectVisitor {
    public  void visitShape(Shape s) {
       // set intersects
   }
   public  void visitRectangle(Rectangle r) {
       // set intersects
   }
    public  void visitCircle(Circle r) {
       // set intersects
   }
}
class CircleIntersectVisitor extends IntersectVisitor { 
   public  void visitShape(Shape s) {
       // set intersects
   }
    public  void visitCircle(Circle r) {
       // set intersects
   }
   public  void visitRectangle(Rectangle r) {
       // set intersects
   }
}


class Intersect {
   public static void Main() {
      Shape s1 = new Rectangle(); 
      Shape s2 = new Circle();
      /* 
      boolean b = s2.intersect(s1);
      b = s1.intersect(s1);
      b = s2.intersect(s1);
      */
      IntersectVisitor v = new RectangleIntersectVisitor();
      s1.accept(v);
      if (v.intersects) {
          ; 
      }
   }
}
\end{java}

\end{enumerate}

\section*{F\#}

see file \texttt{rbTreeSolution.fs}
and file \texttt{mutableSolution.fs}


\end{document}

