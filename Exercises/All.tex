\documentclass{article}

\usepackage[utf8x]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{todonotes}
\usepackage[english]{babel}
%\usepackage{times}
\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{textcomp}

\newcommand{\percents}[1]{\protect \marginpar[l]{\bf [#1]}}
\newcounter{question}
\newcommand{\question}[1]{
  \addtocounter{question}{1}
  % {\bf Exercise~\arabic{question}} \percents{#1}
  \paragraph{Exercise~\arabic{question}  \percents{#1}}
 }
\newenvironment{ex}[1]{\question{#1}}{\vspace{1em}}
\newenvironment{ans}{\begin{framed}\paragraph{Answer~to~exercise~\arabic{question}}}{\end{framed}}
\newcommand{\removed}[1]{}
\newcommand{\correctedLastYear}[1]{}
\newcommand{\correctedThisYear}[1]{,@#1}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{framed}

\newcommand\DeactivateAnswers{}

\begin{document}

\title{Programming Paradigms: Exercises}
\maketitle


\section{Generalities}

\subsection{Paradigms, Languages, Features}
Consider the language C++ (or your favourite programming language,
...).

\question{*} Write a list of features (programming constructs)
implemented in C++. Be as exhaustive as you can (list at least 10
features).

\question{*} For each programming paradigm (Imperative, OO, etc.),
evaluate how well C++ supports that paradigm. Argue using the list
compiled in the previous answer.

\question{***} Can you identify a paradigm not studied in the course
which is supported by C++?

\subsection{Types}

\question{*} Give a meaningful type to the following values.

\begin{enumerate}
\item 4
\item 123.53
\item 1/3
\item $\pi$
\item 'c'
\item ``Hello, world!''
\item -3
\item (unary) -
\item (binary) +
\item sin
\item derivative
\end{enumerate}

\begin{ex}{**,@1}
Explain the meaning of the following types. (Hint: what
kind of values can inhabit those types?)

\begin{enumerate}
\item String
\item String → String
\item String → String → String
\item (String → String) → String
\item String → (String → String)
\item (String → String) → (String → String)
\end{enumerate}
% FIXME: the above already has an implicit notion of currification, so
% the exercise should be split/simplified.

\begin{ans}
Example of values which have these types:
  \begin{enumerate}
   \item a string constant
   \item a function that reverses/doubles/etc a string
   \item a concatenation function
   \item a function that evaluates a function on some constant string
   \item same as 3
   \item a function that reverses a function
  \end{enumerate}
\end{ans}

\end{ex}

One can not only parameterize over values, but also over
types. (Eg. in Java, generic classes).

For example, the following type is a suitable type for a sorting
function: it expresses that the function works for any element type,
OBas long as you can compare its inhabitants.

∀ a. (a → a → Bool) → Array a → Array a


\question{**} Does \texttt{sort} in your favourite language have a similar
type? How close/far is it?

Consider the type
\[∀ a\,b. \mathsf{Pair}\,a\,b → \mathsf{Pair}\,b\,a\]
\question{***} What programs can possibly have this type?


\newpage % so the algorithm below is not broken
\section{Imperative Programming}

\subsection{Gotos to loops}

Consider the algorithm:

\begin{itemize}
\item \textbf {Preliminary:} {\it A} is an array of integers of length
  {\it m} and {\it B} is an array of integers of length {\it n}. Also
  the elements from both arrays are distinct (from the elements in
  both arrays) and in ascending order.

\item \textbf{Step1:} if {\it n} or {\it m} is zero
  \textbf{STOP}. Otherwise if  $m\textgreater n$, set $t := \lfloor log
    \left ( m \slash n \right ) \rfloor $  and go to \textbf{Step4},
    else set $t := \lfloor log
    \left ( n \slash m \right ) \rfloor $.

\item \textbf{Step2:} compare {\it A[m]} with {\it B[n + 1 -
    $2^t$]}. If {\it A[m]} is smaller, set {\it n := n - $2^t$} and
  return to \textbf{Step1}.

\item \textbf{Step3:} using binary search(which requires exactly {\it
    t} more comparisons), insert {\it A[m]} into its proper place
  among {\it B[n + 1 -$2^t$] ... B[n]}. If {\it k} is maximal such
  that {\it B[k] \textless A[m]}, set {\it m := m - 1} and {\it n :=
    k}. Return to \textbf{Step1}.

\item \textbf{Step4:}(Step 4 and 5 are like 2 and 4, interchanging the
  roles of {\it n} and {\it m}, {\it A} and {\it B}) if {\it B[n]
    \textless A[m+1-$2^t$]}, set {\it m := m - $2^t$} and return to
  \textbf{Step1}.

\item \textbf{Step5:} insert {\it B[n]} into its proper place among
  the {\it A}s. If {\it k} is maximal such that {\it A[k] \textless
    B[n]}, set {\it m := k} and {\it n := n - 1}. Return to \textbf{Step1}.


\end{itemize}


\question{*}

implement binary search without gotos in the context of the
algorithm. There is a slight change compared to the classical
algorithm, since the scope of the search is different. Keep in mind!
\footnote{If that is too easy, do it for red-black trees.}


\question{-}

\textbf{Step1} may require the calculation of the expression $\lfloor log
    \left ( m \slash n \right ) \rfloor $, for $n \geq m$. Explain how
    to compute this easily without division or calculation of a
    logarithm.  % \todo[inline]{with gotos or explicit stack}

\question{*}

Why does the binary search mentioned in the algorithm
always take {\it t} steps ?

\question{*}

Explain the behaviour of the algorithm for the arrays
{\it A} = \{87, 503, 512\} and {\it B} = \{61, 154, 170, 275, 426, 509,
  612, 653, 677, 703, 765, 897, 908\}.

\question{**,@1}

Implement the above-mentioned algorithm without using
{\it gotos} in a programming language of your choice. Check your
implementation with the {\it A} and {\it B} from the previous question.

\begin{ans}
  \inputminted[firstline=37]{c}{dan/merge/merge.c}
\end{ans}

\subsection{Control flow statements to gotos}
\question{*,@1}

Translate the following \textbf{for} loop with explicit gotos:
\begin{minted}{c}
for (statement1; condition; statement2)
  loop_body
\end{minted}

\begin{ans}
  \begin{minted}{c}
    statement1;
    loop:
    if (condition) {
        loop_body;
        statement2;
        goto loop;
    }
  \end{minted}
\end{ans}

\question{*}

Translate the following \textbf{foreach} loop with explicit gotos:
\begin{verbatim}
  foreach i in k..l do
    body
\end{verbatim}

\question{*}
Translate the do/while construct.

\question{*,@1}
Translate the switch/case construct.

(If you want to make sure your translation is correct you should check the
specification of the C language. \url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf})

\begin{ans}
The following \texttt{switch}-snippet
\begin{minted}{c}
switch(a) {
    case pattern1: statement1; break;
    case pattern2: statement2;
    default: def_statement;
}
\end{minted}
can be translated like this:
\begin{minted}{c}
if (var == pattern1) goto case_1;
if (var == pattern2) goto case_2;
goto case_default;

case_1:       statement1; goto case_end;
case_2:       statement2;
case_default: def_statement;
case_end:
\end{minted}


\paragraph{Note}
The following translation is incorrect due to the fall-through
behaviour of switch in C.
\begin{minted}{c}
if (var == pattern1) {
    statement1;
} else if (var == pattern2) {
    statement2;
} else
    def_statement;
\end{minted}

\end{ans}

\question{*}
Translate the insertion sort algorithm.



\subsection{Pointers and call by reference}

\question{*}
Create a binary search tree where nodes contain integer number in
C/C++/Java. Implement a function that adds a value to the tree and one that
deletes a certain value from the tree.

\question{*}
Write a recursive traversal of the above tree.

\question{*,@1}
Write a swap function using call by reference.

\begin{ans}
In C++ syntax:
\begin{verbatim}
    void swap(int& a, int& b) {
        int t = a;
        a = b;
        b = a;
    }
\end{verbatim}
\end{ans}

\question{*,@1}
Write a swap function using call by value.

\begin{ans}
  Merely using call by value won't work because only copies of values
  will be changed, local variables are destroyed when function
  returns.  Note the absence of \&'s in the signature.
\begin{minted}{c}
    void swap(int a, int b) {
        int t = a;
        a = b;
        b = t;
    }
\end{minted}
The standard way is then to pass pointers (make the references
explicit):
\begin{minted}{c}
      void swap(int* a, int* b) {
        int t = *a;
        *a = *b;
        *b = t;
      }
\end{minted}
  But it is also possible to use a copy parameters back and forth, for
  example using a structure.
\begin{minted}{c}
    typedef struct {
        int fst;
        int snd;
    } pair;

   struct pair swap(struct pair p) {
        int t = p.fst;
        p.fst = p.snd;
        p.snd = p.fst;
        return p;
    }
\end{minted}
\end{ans}

\question{**} Does Java use call by reference or call by value? Give
examples to support your answer.

\begin{ans}
  Java calling convention is a mishmash:
 \begin{itemize}
 \item Scalars are passed by value
 \item Objects are passed by reference, but with a catch, see below.
 \end{itemize}
\begin{minted}{java}
void f(Object x) {
  x = null; -- this will only change the local copy of x
}
...
y = new Object();
f(y);

-- pitfall: y != null
\end{minted}

 In sum, the calling convention of Java is "what you would do normally
 in C"... Not a very clean semantics.
\end{ans}

\question{**,@1} Write down pros and cons of using call by reference
vs. call by value. (Ease of use, performance, ...)

\begin{ans}
  Use call-by-value to protect the data from occasional corruption by a buggy
  procedure. Use call-by-reference if arguments are too big to be passed on
  stack.
\end{ans}

\subsection{More on control flow and pointers: Duff's device}
Duff's device is an optimization idiom for serial copies
in the language C. The fragment below lists first the original code,
then Duff's optimization.
\pagebreak
\begin{minted}{cpp}
/* (Almost) original code */
int main() {
   short *to, *from;
   int count;
   ...
   {
     /* pre: count > 0 */
     do
	  *to++ = *from++;
     while(--count>0);
   }
   return 0;
}
\end{minted}

Many things happen in the assignment ``\textsf{*to++ = *from++;}''. Can you figure out what exactly?
\begin{ex}{*}
  Translate the above to multiple statements, so that for each of them
  only one variable (or memory location) is updated.  Explain in your
  own words what happens (draw a picture if necessary).
  \begin{ans}
    It is equivalent to \texttt{*to = *from; to++; from++;}.  In other
    words, the memory pointed by \texttt{from} is copied to the memory
    pointed by \texttt{to}, then the pointers are incremented.
  \end{ans}
\end{ex}


Duff optimised the above code as follows:
\begin{minted}{cpp}
/* Duff's transformation */
int main() {
  short *to, *from;
  int count;
  ...
  {
     /* pre: count > 0 */
     int n = (count + 7) / 8;
     switch(count % 8){
       case 0:	do{	*to++ = *from++;
       case 7:	        *to++ = *from++;
       case 6:	        *to++ = *from++;
       case 5:	        *to++ = *from++;
       case 4:	        *to++ = *from++;
       case 3:	        *to++ = *from++;
       case 2:	        *to++ = *from++;
       case 1:	        *to++ = *from++;
                } while (--n > 0);
     }
  }
  return 0;
}
\end{minted}

\begin{ex}{**}
  Translate the switch statements to gotos.
\end{ex}

Is the second program really equivalent to the first?

\begin{ex}{-}
Show that the instruction ``\texttt{*to++ = *from++}'' will be executed
\texttt{count} times in the second program.
\begin{ans}
The while loop will be executed $\floor{(count + 7) / 8}$ times.
Since each iteration executes the instruction 8 times, we expect the
program to run it $8 \times \floor{(count + 7)/ 8}$ times in total, which
is up to 7 times more than count.

However, the \texttt{switch} instruction is there to skip
$count \bmod 8$ instructions in \emph{the first iteration}, to
make the count exact.
\end{ans}
\end{ex}

\begin{ex}{****}
  Explain the equivalence by a series of program transformations.
\end{ex}

\providecommand{\floor}[1]{\lfloor #1 \rfloor}
\begin{ex}{-}
  Can you guess why Duff expects the second program to be faster?
  What instructions are executed in the first program but not in the
  second?

  \begin{ans}
    The test and jump instructions are executed only $\floor{(count +
      7) / 8}$ times instead of $count$, which is about $1/8$ of the
    time.
  \end{ans}
\end{ex}


\paragraph{Further reading}
\begin{itemize}
\item For the original email in which Tom Duff presented his ``device'',
see

\url{http://www.lysator.liu.se/c/duffs-device.html}

\item You can see the assembly code generated by \textsf{gcc} by
  compiling with
  \begin{center}
    \textsf{gcc -S $<$filename$>$}.
  \end{center}
\end{itemize}


\subsection{From recursion to explicit stack}
\begin{ex}{**,@2}
Re-implement the tree traversal (from above), but using explicit stacks.
\begin{ans}
\inputminted[firstline=52,lastline=62]{c}{dan/trav/trav.c}
\end{ans}
\end{ex}


Consider the following recursive equation for computing Fibonacci
numbers:
\providecommand{\fib}{\mathnormal{fib}}
\[
\fib_{n+2} = \fib_{n+1} + \fib_{n}
\]

\question{*}
Implement the recursive function computing the n-th Fibonacci number based on
the expression above.

\question{*} What is the complexity of the computation? (How many
calls will there be to compute $fib_{n}$?)

\question{*} Implement a slightly-optimized recursive function for the
same purpose, using an accumulator parameter.

\question{**} Implement a version of each of the two functions above
by using an explicit stack.

Consider the following function:
\begin{minted}{c}
void move_many(int n, int source, int intermediate, int target) {
  if (n != 0) {
    move_many(n-1,source,target,intermediate);
    move_disk(source,target);
    move_many(n-1,intermediate,source,target);
  }
}
\end{minted}
\question{**} Remove recursion, using an explicit stack.

\question{**} Eliminate the tail call. (Do not use the stack for
them).

\question{***} The structure of the other call is particular: it is
possible to recover the arguments of the caller from the arguments of
the call. Use this property to avoid using the stack for these
arguments.

\question{**}
Implement the Ackermann function without recursion.
(See \url{http://en.wikipedia.org/wiki/Ackermann_function}).

\question{**} Implement the algorithm from the previous section
without loops (only recursion allowed).

\question{**}
Translate the quicksort algorithm.

\question{**} For each of the following: implement the algorithm as a
recursive function. (And remove the loop!)
\begin{enumerate}
\item
\begin{verbatim}
-- n given
x = 1
while n > 0 do
  b = least_significant_bit(n);
  n = n / 2;
  x = x * x + b;
return x
\end{verbatim}

\item

\begin{verbatim}
a = 0
b = 1
for i in [1..n] do
  c = a + b
  a = b
  b = c
return a
\end{verbatim}
\end{enumerate}
\newpage % avoid breaking up the code which follows.
\section{Object-Oriented Programming}

Consider the following code, in C\# syntax:
\begin{minted}{csharp}
interface Monoid {
   Monoid op(Monoid second);
   Monoid id();
};

struct IntegerAdditiveMonoid : Monoid {
    public IntegerAdditiveMonoid(int x) {
         elt = x;
    }
    public IntegerAdditiveMonoid op(IntegerAdditiveMonoid second) {
         return new IntegerAdditiveMonoid(
             elt + second.elt);
    }
    public IntegerAdditiveMonoid id(){
         return new IntegerAdditiveMonoid(0);
    }
    int elt;
};

\end{minted}
%

\subsection{Explicit method pointers}

\question{*,@2} Translate the above code to a C-like language, using
explicit method pointers. (Hint: you can simply consider the interface
as a class without fields.)

\begin{ans}
  \begin{minted}{c}
    #include "stdio.h"
    #include "stdlib.h"

struct monoid {
  struct monoid_vtable *vtable;
};

typedef struct monoid Monoid;

struct monoid_vtable {
  Monoid *(*op)(Monoid *this, Monoid *second);
  Monoid *(*id)(Monoid *this);
};

typedef struct monoid_vtable Monoid_Vtable;

struct integerAdditiveMonoid {
     Monoid* super;
     int elt;
};

typedef struct integerAdditiveMonoid IntegerAdditiveMonoid;

IntegerAdditiveMonoid *integerAdditiveMonoid_new(int x);

Monoid *integerAdditiveMonoid_op(Monoid *this, Monoid *second) {
     return (Monoid *)
         (integerAdditiveMonoid_new(((IntegerAdditiveMonoid*) this)->elt
         + ((IntegerAdditiveMonoid *) second)->elt));
};

Monoid *integerAdditiveMonoid_id(Monoid *this) {
     return (Monoid *) (integerAdditiveMonoid_new(0));
}

Monoid_Vtable integerAdditiveMonoid_vtable =
{  &integerAdditiveMonoid_op
  , &integerAdditiveMonoid_id };

IntegerAdditiveMonoid *integerAdditiveMonoid_new(int x) {
     IntegerAdditiveMonoid *this =
         malloc(sizeof(IntegerAdditiveMonoid));
     this->super = malloc(sizeof(Monoid));
     this->super->vtable = &integerAdditiveMonoid_vtable;
     this->elt = x;
     return this;
}

int main() {
     IntegerAdditiveMonoid *a = integerAdditiveMonoid_new(3);
     IntegerAdditiveMonoid *b = integerAdditiveMonoid_new(4);
     printf("%d\n",((IntegerAdditiveMonoid*)
         (a->super->vtable->op((Monoid *) a, (Monoid *) b)))->elt);
     printf("%d\n",((IntegerAdditiveMonoid*)
         (b->super->vtable->id((Monoid *) b)))->elt);
     free(a);
     free(b);
     return 0;
}

  \end{minted}
\end{ans}


\question{-} Briefly recap: what is a \textit{monoid}, mathematically?

\question{-} Give two examples of data types that can be considered monoids.
(Hint: Strings would form a monoid under the appropriate structure; what is the structure?

\question{*} Write another instance of the monoid interface, using one
of the examples you found. Also write its translation to a C-like
language.

\question{*} Assume variables \textsf{a,b} of type \textsf{Monoid}. Translate
the expression \textsf{a.op(b)}.

\question{*} Assume to objects \textsf{x,y} of two different instances
of Monoid are bound to the variables \textsf{a,b}. Explain what
happens at runtime when the expression is evaluated. (Which code is executed?)

\subsection{Co/Contra variance}

Surprise: the above code is refused by the C\# compiler:
\begin{verbatim}
> gmcs Monoids.cs
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement
  interface member `Monoid.op(Monoid)'
Monoids.cs(2,11): (Location of the symbol related to previous error)
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement
  interface member `Monoid.id()'
Monoids.cs(3,11): (Location of the symbol related to previous error)
Compilation failed: 2 error(s), 0 warnings
\end{verbatim}


\question{*,@2} What if the method \textsf{op} \textit{would} compile?
Define objects \textsf{a,b}, of appropriate types, so that
\textsf{a.op(b)}, if is run, would result in a run-time error.

\begin{ans}
  \begin{minted}{csharp}
    a = new IntegerAdditiveMonoid(3);
    b = new IntegerAdditiveMonoid(4);
    a.op(b);
  \end{minted}

\begin{verbatim}
error: method op() not found
\end{verbatim}

\end{ans}

\question{*,@2} What if the method \textsf{id} would compile? Could you
construct a similar run-time error? (Hint: do the translation job if
the answer is not obvious to you.)

\begin{ans}
  \begin{minted}{csharp}
    a = new IntegerAdditiveMonoid(3);
    a.id();
  \end{minted}

\begin{verbatim}
error: method id() not found
\end{verbatim}
\end{ans}

\question{**,@2} Explain the error messages in terms of co-/contra-/nonvariance.

\begin{ans}
  In an interface implementation, types should be covariant, because the users
  of the interface expect to supply arguments of generic types and to get a
  return value of a generic type, not of the narrow ones.
\end{ans}

\question{***} The corresponding program in Java behaves differently. Briefly
explain how, consult the Java Language Specification (JLS), and back your answer
with the appropriate clause(s) in the JLS.

\question{-} Can you change the code so that the (current)
C\#-compiler accepts it? What is the problem then?

\removed{
\subsection{Dynamic dispatching \& the visitor}

Suppose the three classes \textsf{Shape}, \textsf{Rectangle}, and
\textsf{Circle}, and the appropriate inheritance relation between them.
Further assume a method \textsf{intersect()} that can determine whether two
shapes overlap. Obviously, the implementation of \textsf{intersect()}
depends on the actual shapes involved.

\question{*} Implement and design the 3 classes so that all possible
intersections of shapes can be properly handled using Smalltalk.  What
is the problem with single dispatching? Name at least 2 issues.


  The following Java snippet redesigns the
  class hierarchy using \textit{double dispatch}.
  Explain how double dispatching works by
  giving the sequence of calls for the line marked (*) in \textsf{Main}.
  Name two problems with double dispatching.

\begin{java}
class Shape {
    public  boolean intersect(Shape s) {
         return s.intersectShape(this);
    }
    protected  boolean intersectShape(Shape s) {
        // intersect Shape x Shape
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // no special code for Shape x Rectangle
        return intersectShape(r);
    }
    protected  boolean intersectCircle(Circle c) {
        return intersectShape(c);
   }
}
class Rectangle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectRectangle(this);
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // Rectangle x Rectangle
        ..
    }
}
class Circle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectCircle(this);
    }
    protected  boolean intersectCircle(Circle c) {
        // Circle x Circle
   }
}

class Intersect {
   public static void Main() {
      Shape s1 = new Rectangle();
      Shape s2 = new Circle();
      boolean b = s2.intersect(s1);        // *
   }
}
\end{java}

The \textit{Visitor pattern} provides an alternative workaround,
also based on double dispatching. In difference
to the solution above, the pattern
introduces two hierarchies, the visited
hierarchy and the visitor hierarchy. In the example,
 \textsf{Shape, Rectangle, Circle}
form the visited hierarchy, \textsf{IntersectVisitor} and its two
subclasses \textsf{RectangleIntersectVisitor} and \textsf{CircleIntersectVisitor}
form the visiting hierarchy. The visited classes are
augmented with a method \textsf{accept}, which uses double dispatching
to call the appropriate ShapeVisitor (and to invoke the
right computation).

\question{*} Complete the code for the two class hierarchies and the client.
\question{*} Name two problems of the visitor approach.

\begin{java2}
class Shape {
    public void accept(IntersectVisitor v) {
	v.visitShape(this);
    }
}
class Rectangle extends Shape {
public  void accept(IntersectVisitor v) {
        // your job
    }
}
class Circle extends Shape {
   // your job
}

// visitor hierarchy
abstract class IntersectVisitor {
    boolean intersects;
    public abstract void visitShape(Shape s);
    public abstract void visitRectangle(Rectangle r);
    public abstract void visitCircle(Circle c);
}

// client code
  Shape s1 = new ..
  IntersectVisitor v = new RectangleIntersectVisitor();
  s1.accept(v);
  if (v.intersects) ...
\end{java2}
}

\section{Functional Programming}
\subsection{Algebraic Data Types and Pattern Matching}

\question{*} Write functions between the types \[(Either\,A\,B,
Either\,C\,D)\] and \[Either (Either (A,C)\, (B,D))\,(Either (A,D)\,(B,C))\].

\begin{ans}
  \inputminted[firstline=3]{haskell}{fp/Ex49.hs}
\end{ans}

\question{*} Define an algebraic type for binary trees

\begin{ans}
  \inputminted[firstline=3]{haskell}{fp/Ex50.hs}
\end{ans}

\question{*,@3} define an algebraic type for arithmetic expressions

\begin{ans}
  \inputminted[firstline=3,lastline=7]{haskell}{fp/Ex51and52.hs}
\end{ans}

\question{*,@3} define a simple interpreter for the above type

\begin{ans}
  \inputminted[firstline=9,lastline=15]{haskell}{fp/Ex51and52.hs}
\end{ans}

\question{*,@3} Translate the above 2 structures to an OO language. (Hint: One
class corresponds to leaves, one to branching.)

\begin{ans}
  \inputminted[]{java}{fp/Ex53/Tree.java}
  \inputminted[]{java}{fp/Ex53/Branch.java}
  \inputminted[]{java}{fp/Ex53/Empty.java}
\end{ans}

\question{*,@3} Translate the interpreter to an OO
language. You are not allowed to use 'instanceof'

\begin{ans}
  \inputminted[]{java}{fp/Ex53to55/Expr.java}
  \inputminted[firstline=3]{java}{fp/Ex53to55/Lit.java}
  \inputminted[firstline=3]{java}{fp/Ex53to55/Add.java}
  \inputminted[firstline=3]{java}{fp/Ex53to55/Mul.java}
  \inputminted[firstline=3]{java}{fp/Ex53to55/Var.java}
\end{ans}

\question{*,@3} Translate the interpreter to an OO language. You must use
'instanceof'.

\begin{ans}
  \inputminted[]{java}{fp/Ex53to55/Eval.java}
\end{ans}

\subsection{Currification and partial application}

\question{*,@3} Define a function \texttt{f} following this spec: given a
integer, return it unchanged if it is greater than zero, and zero
otherwise. (The type must be \texttt{Int → Int}.)

\begin{ans}
  \inputminted[firstline=7,lastline=9]{haskell}{fp/Ex56to59.hs}
\end{ans}

\question{*,@3} Assuming a function max : \texttt{(Int × Int) → Int}, define the function \texttt{f}.

\begin{ans}
  \inputminted[firstline=15,lastline=16]{haskell}{fp/Ex56to59.hs}
\end{ans}

\question{*,@3} Define a function \texttt{max'}, by currifying the function \texttt{max}.

\begin{ans}
  \inputminted[firstline=19,lastline=20]{haskell}{fp/Ex56to59.hs}
\end{ans}

\question{*} Define \texttt{f} using \texttt{max'}.

\begin{ans}
  \inputminted[firstline=23,lastline=24]{haskell}{fp/Ex56to59.hs}
\end{ans}

\subsection{Higher-order functions}

Assume the \texttt{filter}, \texttt{map}, \texttt{foldr} functions as in the Haskell prelude. \texttt{f
} comes from the previous section.

\question{*,@3} For each of the following
expressions, remove occurences of the higher-order functions by
inlining them.
\begin{minted}{haskell}
exp1 = map f
exp2 = filter (>= 0)
exp3 = foldr (:) []
exp4 = foldr (++) []
exp5 = foldr (\ x xs -> xs ++ [x]) []
\end{minted}
%

\begin{ans}
  \inputminted[]{haskell}{fp/Ex60.txt}
\end{ans}

Consider the following imperative program:
\begin{minted}{c}
for (i=0;i<sizeof(a);i++)
  if (a[i].grade >= 24)
     *b++ = a[i];
\end{minted}
\begin{ex}{*,@3}
  How would the same algorithm be naturally expressed in a functional
  language? (Use functions from the Haskell prelude to shorten your code)
\end{ex}

\begin{ans}
  \inputminted[firstline=7,lastline=9]{haskell}{fp/Ex61.hs}
\end{ans}

Assume we represent a vector as a list of integers.

\question{*} write a function that does the dot-product of two
vectors using explicit recursion and pattern matching.

\begin{ans}
  This can be done with two functions, or with an accumulating parameter. The latter is shown here:
  \inputminted[firstline=1,lastline=5]{haskell}{fp/Ex62.hs}
\end{ans}

\question{*} In the above code, abstract over sum and products on integers.

\begin{ans}
    We use \texttt{sum} and \texttt{zipWith}, from \texttt{Data.List}
    (answers the next question, too).
    Note that this solution does not error if the lists are of different
    lengths (unlike the answer to the previous question).
  \inputminted[firstline=9,lastline=9]{haskell}{fp/Ex62.hs}
\end{ans}

\question{**} Can you find the functions you created in the Haskell
\texttt{Data.List} module?

\question{}
The standard function \verb!insert! inserts an element into an ordered
list, for example
\[ \verb!insert 4 [1,3,5,7]! = \verb![1,3,4,5,7]! \]
Define a function
\begin{verbatim}
sort :: [Integer] -> [Integer]
\end{verbatim}
to sort lists, using \texttt{insert}.

\begin{ans}
  \inputminted[firstline=5,lastline=7]{haskell}{fp/Ex65to66.hs}
\end{ans}

\question{} Express \texttt{sort} in terms of \texttt{foldr} (do not
use explicit recursion).

\begin{ans}
  \inputminted[firstline=9,lastline=10]{haskell}{fp/Ex65to66.hs}
\end{ans}

\DeactivateAnswers

\subsection{Closures}

% Assume zipWith as defined in the Data.List module.

Consider the program:
\begin{verbatim}
test1 xs = foldr (+) 0 xs
test2 xs = foldr (*) 1 xs
\end{verbatim}

\begin{ex}{*\correctedLastYear 4}
  Identify higher-order applications in the above program.
\end{ex}

\begin{ans}
  \texttt{foldr},
  \texttt{(+)} and
  \texttt{(*)}.
\end{ans}

\begin{ex}{*\correctedLastYear 4,@4}
  Assuming that \texttt{xs} are lists of integers, replace the above
  uses of higher-order application by explicit closures.  (Hint: you
  need to also change the definition of \texttt{foldr}/\texttt{map}).
\end{ex}

\begin{ans}
  \inputminted[firstline=4]{haskell}{fp/Ex70to71.hs}
\end{ans}

\begin{ex}{**\correctedLastYear 4,@4}
  Add the following lines to the above program and repeat the above 2
  exercises.
\begin{minted}{haskell}
replace a b xs = map (\x -> if x == a then b else x) xs
moment n xs = sum (map (\x -> x ^ n) xs)
\end{minted}
\end{ex}

\begin{ans}
  \inputminted[firstline=4]{haskell}{fp/Ex72.hs}
\end{ans}

\question{*}
Eratosthenes' sieve is a method for finding prime numbers, dating from
ancient Greece. We start by writing down all the numbers from 2 up to
some limit, such as 1000. Then we repeatedly do the following:
\begin{itemize}
\item
The {\em first} number in the list is a prime. We generate it as an
output.
\item
We {\em remove all multiples} of the first number from the
list---including that number itself.
\item
Loop.
\end{itemize}
We terminate when no numbers remain in our list. At this point, all
prime numbers up to the limit have been found.

Write the algorithm in Haskell.
\begin{ans}
  See next question.
\end{ans}
\question{*\correctedLastYear 4}

Consider the following algorithm:
\begin{verbatim}
primes = sieve [2..1000]
sieve (n:ns) = n:sieve (filter (not . (`isDivisibleBy` n)) ns)
x `isDivisibleBy` y = x `mod` y == 0
\end{verbatim}

Inline the call of function composition in the above as a
lambda abstraction.

The only remaining higher-order function is filter.

\question{*\correctedLastYear 4} Write a version of filter which takes an explicit
closure as an argument.  Remember to write (and use) an apply
function. Hint: in order to test your program you need to define an
example parameter, such as $(>= 0)$, etc.

\question{*} Re-write sieve using the above.

\question{**} Write a version of sieve in imperative (or OO) language,
by translation of the answer to the previous exercise. (eg. you can
not use arrays instead of lists). (Hint: write this one as a recursive program).

\subsection{Explicit state}

Consider a binary tree structure with integer values in the nodes.

\question{*\correctedLastYear 4,@4} In the Java version, write a function that replaces each
element with its index in preorder traversal of the tree.

\begin{ans}
  \inputminted[]{java}{fp/Ex78/Tree.java}
  \inputminted[]{java}{fp/Ex78/Preorder.java}
\end{ans}

\question{**\correctedLastYear 4,@4} Translate the function above to Haskell thinking of it
as an imperative algorithm. You should use \emph{IP} from the lecture notes.
What is the ``state of the world'' in this case?

\begin{ans}
  \inputminted[]{haskell}{fp/Ex79.hs}
\end{ans}

\question{*\correctedLastYear 4} Rewrite the Haskell version, in such a way that passing
``state of the world'' is made visible as such, that is, eliminate your
usage of \emph{IP}.


\subsection{Laziness}
There are no lazy languages that permit mutation.  \question{*** \correctedLastYear 5} Why not?

\subsubsection{Lazy Dynamic Programming}

Consider a the function computing the fibonacci sequence:
\begin{verbatim}
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
\end{verbatim}

\question{-} Estimate the time-complexity of computing $\mathsf{fib}\,n$.

One can make the above computation take linear time by saving the
intermediate results in an array:
\begin{verbatim}
fibs[0] = 0
fibs[1] = 1
for i = 2 to n do
  fibs[n] = fibs[n-1] + fibs[n-2]
\end{verbatim}

\question{*} Instead of specifying the order of filling the array via
an imperative algorithm, let Haskell's lazy evaluation take care of it.
Write the definition of the array $\mathsf{fibs}$ in Haskell.

\question{*} What portion of the array is forced when
$\mathsf{fibs}!k$ is accessed? Draw the graph of computation
dependencies for $k=5$.


\question{*\correctedLastYear5} Write the Floyd-Warshall algorithm in your favourite
imperative language. Assume that there is no weight on edges; and
you're only interested in whether there is a path between two given
nodes, not the number of steps in the path.

Note that the best-case performance is Cubic.

\question{*} Repeat the above, but make sure you never overwrite a
cell in a matrix. (What do you need to do to make this at all
possible?)

\question{*\correctedLastYear5} Using the same formula, fill the Roy-Warshall matrix
using an array comprehension in a lazy language (optionally use
explicit thunks for the contents of each cell). Discuss the best-case
performance.

\question{-} Does your favourite spreadsheet program have strict, or
lazy logical disjunction operator? Test it.

\question{-} Can you write the Roy-Warshall algorithm in it?

\question{**} Repeat the above steps with the algorithm to compute the
least edit distance. \url{http://en.wikipedia.org/wiki/Levenshtein_distance}

\begin{verbatim}
int LevenshteinDistance(char s[1..m], char t[1..n])
{
  // for all i and j, d[i,j] will hold the Levenshtein distance between
  // the first i characters of s and the first j characters of t;
  // note that d has (m+1)x(n+1) values
  declare int d[0..m, 0..n]

  for i from 0 to m
    d[i, 0] := i // the distance of any first string to an empty second string
  for j from 0 to n
    d[0, j] := j // the distance of any second string to an empty first string

  for j from 1 to n
  {
    for i from 1 to m
    {
      if s[i] = t[j] then
        d[i, j] := d[i-1, j-1]       // no operation required
      else
        d[i, j] := minimum
                   (
                     d[i-1, j] + 1,  // a deletion
                     d[i, j-1] + 1,  // an insertion
                     d[i-1, j-1] + 1 // a substitution
                   )
    }
  }

  return d[m,n]
}
\end{verbatim}

\begin{ans}
\inputminted{haskell}{Diff.hs}
\end{ans}

\subsubsection{Lazy Lists (Streams)}

Remember the sieve algorithm. Lazy lists can be (potentially)
infinite, although of course no program can evaluate {\em all} the
elements of an infinite list. Nevertheless, using lazy lists can help
us avoid building unnecessary limitations into our code.  Check that
the \verb!sieve! function also works given the {\em infinite} list
\verb![2..]!---the output should be the {\em infinite} list of all
prime numbers.

\begin{ex}{*\correctedLastYear5}
How would you find the first 100 prime numbers?
\begin{ans}
  \begin{minted}{haskell}
    test = take 100 primes
  \end{minted}
\end{ans}
\end{ex}

Hint: start by answering the following questions on a simpler
algorithm, for example the function \textsf{enumFrom} which generates
the infinite list of numbers starting at a given one.

\begin{ex}{*\correctedLastYear5} Translate \textsf{sieve} to use explicit thunks.
  \begin{ans}
    \inputminted{haskell}{Sieve1.hs}
  \end{ans}
\end{ex}
Oh noes, this introduced higher-order function(s).

\begin{ex}{**}
  Where are the new higher-order functions?
\end{ex}

You know what's coming...

\question{***} Remove higher-orderness using the best technique available.
\begin{ans}
\inputminted{haskell}{Sieve2.hs}
\end{ans}

\newcommand{\inputjava}[1]{
\texttt{#1}:
\inputminted{java}{#1}
}

\begin{ex}{**\correctedLastYear5}
  Write a version of lazy sieve in imperative (or OO)
language.
\begin{ans}
\inputjava{SieveJava/Thunk.java}
\inputjava{SieveJava/CommonLazyLists.java}
\inputjava{SieveJava/LazyList.java}
\end{ans}
\end{ex}

Since there are no more functions in the data, you can now display your
infinite lists.

\question{***} Do so for a few meaningful inputs, and interpret what
you see.
\begin{ans}
 \inputjava{SieveJava/Main.java}
\end{ans}



\section{Concurrent Programming}

\subsection{Channels and Processes}

\begin{ex}{*\correctedLastYear5}
  Write a process that manages a bank account. It has a channel for
  queries; which can be deposits and withdrawals. The answer is posted
  to a channel that comes with the query.  (Note: you cannot use
  references to store any state -- see variable-managing process for inspiration)
\end{ex}

\begin{ex}{*}
  Write a client for the above process that move ``money'' from an
  account to another. (``transaction'')
\end{ex}

\begin{ex}{*}
  Assume that withdrawals/deposits can fail. (For example if there is
  too much/litte on the account). Modify the server process
  accordingly.
\end{ex}

\begin{ex}{**\correctedLastYear5}
  Is the total amount of money a constant of your system? (Consider
  that transactions may fail in the ``middle''.) How can you ensure
  that it is?  Write the corresponding code.
\end{ex}

\begin{ex}{*}
  Implement a process that manages a semaphore.  The process should
  implement the requests P and V. (See the wikipedia article for
  explanation of semaphore, P and
  V). \url{http://en.wikipedia.org/wiki/Semaphore_(programming)}
\end{ex}

\begin{ex}{*}
  Implement two library functions that help communicate with the above
  server. (Hint: you may have to create channels.)
\end{ex}

\subsection{Explicit continuations}

Consider the following outline for the ``business logic'' of a
web-application:
\begin{verbatim}
session connection = do
   items <- webForm connection "What do you want to buy?"
   address <- webForm connection "Where do you want your stuff delivered?"
   daMoney <- webForm connection "Enter your credit card details, now."
   secureInDatabase daMoney (priceOf items)
   placeOrder items address
\end{verbatim}

\begin{ex}{*\correctedLastYear6}
  What is the purpose, and type of the webForm primitive?
\end{ex}

\begin{ex}{**\correctedLastYear6}
  Transform the type of webForm to take a continuation.
\end{ex}

\begin{ex}{**\correctedLastYear6}
  Break the above code into continuations, linked by the webForm primitive.
\end{ex}

\begin{ex}{***\correctedLastYear6}
  Outline what the webForm function should do. Discuss in particular
  what happens if the user presses the ``back'' button in their
  browser.
\end{ex}


\paragraph{Recursion and continuations}

Remember your interpreter for arithmetic expressions. It should have type:

% eval (Add x y) = eval x + eval y

Expr → Int

Let's make continuations explicit. In this case, the result is not
returned directly, but applied to a continuation. Hence, the type
becomes:

Expr → (Int → a) → a

\question{*\correctedLastYear6} Write a wrapper for the interpreter which has the above type

% wrapper expr k = k (eval expr)


\question{***\correctedLastYear6} Replace every recursive call in the interpreter by a
call to the wrapper.  (Hint: you must decide what is the
``continuation'' for every call, and for this you must choose an order
of evaluation!)
% eval (Add x y) = wrapper x (\a -> wrapper y (\b -> a + b))

\question{***\correctedLastYear6} Unfold the usage of the interpreter in the wrapper.

% wrapper (Add x y) k = k (wrapper x $ \a -> wrapper y $ \ b -> a + b)


% It would be nice to have the students find:


% eval (Add x y) k = (eval x (\a -> eval y (\b -> k (a + b))))



\section{Logic Programming}

In this section, exercises are sometimes formulated both in Prolog and Curry syntax; as indicated in the margin.
\providecommand{\Prolog}{{\tiny Prolog}}
\providecommand{\Curry}{{\tiny Curry}}
\subsection{Metavariables and unification}

\begin{ex}{*\correctedLastYear6}
What is the result of each of the following unifications?
Try to come up with the result without using the prolog/curry interpreter!

\Prolog{}
\begin{minted}{prolog}
a(X,Y) = a(b,c)
a(X,Y) = a(Z,Z)
a(X,X) = a(b,c)
e(X) = a(b,b)
d(X,X,Y) = d(Z,W,W)
a(X,X) = d(Z,W,W)
\end{minted}


\Curry{}
\begin{verbatim}
data X = A X X | B | C | D X X X | E X

A x y =:= A B C  where x, y free
A x y =:= A z z  where x, y, z free
A x x =:= A B C where x free
E x =:= A B B where x free
D x x y =:= D z w w where x, y, w, z free
A x x =:= D z w w where x, y, w, z free
\end{verbatim}

\begin{ans}
\begin{tabular}{c}
X = b, Y = c \\
X = Y = Z \\
fail \\
fail \\
X = Y = Z = W \\
\end{tabular}
\end{ans}
\end{ex}

\begin{ex}{*}
  Assume a relation \textsf{plus} relating two natural numbers and
  their sum.

  Define a relation \textsf{minus}, relating two natural numbers and
  their difference, in terms of \textsf{plus}.
\end{ex}

\subsubsection{Difference Lists}

A difference list is a special structure that can support efficient
concatenation. It uses unification in a clever way to that end.

The difference-list representation for a list can be obtained as follows:

\Prolog{}
\begin{minted}{prolog}
fromList([],d(X,X)).
fromList([A|As],d(A:Out,In)) :- fromList(As,d(Out,In)).
\end{minted}


\Curry{}
\begin{verbatim}
data DList a = D [a] [a]

fromList :: [a] -> D a -> Success
fromList [] (D x x') = x =:= x'
fromList (a:as) (D (a':o) i) = a =:= a' & fromList as (D o i)
\end{verbatim}


A structure of the form \textsf{d(Out,In)} will represent the list
\textsf{L} if \textsf{Out} unifies with \textsf{L} concatenated with
\textsf{In}. Or, less technically, a list L will be represented as the
difference between Out and In: so for instance,

\Prolog{
$$[1,2] \longrightarrow d([1,2,3,4],[3,4])$$
}
\Curry{
$$[1,2] \longrightarrow D [1,2,3,4] [3,4] $$
}


You can check how fromList works by testing it:
\Prolog{
\begin{minted}{prolog}
fromList([1,2,3],X).
\end{minted}
}
\Curry{
\begin{verbatim}
fromList [1,2,3] x where x free
\end{verbatim}
}
Note that the same metavariable (G271 in my implementation) is present twice in
the result. Note that we can get the original result back by unifying this
metavariable with the empty list.

\begin{question}{**\correctedLastYear6}
Write a predicate \textsf{toList :: DList a $\rightarrow$ [a] $\rightarrow$ Success} to get back to the normal list representation.

\begin{ans}
~
\begin{minted}{prolog}
toList(d(X,X),[]).
toList(d(Head:Rest,Tail),[Head|OtherTail]):- toList(d(Rest,Tail),OtherTail).
\end{minted}

\begin{minted}{haskell}
toList (D x y) []
   = x =:= y
toList (D (head:rest) tail) (head':otherTail)
   = head =:= head' &
     toList (D rest tail) otherTail
\end{minted}

\end{ans}

\end{question}

Given that representation for lists, it is possible to perform concatenation by
doing unification only!

\begin{ex}{**\correctedLastYear6}
Write a predicate dconcat to concatenate two difference lists, without
using the direct representation.

If \texttt{dconcat} is properly defined, then the queries
\Prolog{
\begin{minted}{prolog}
dconcat(X,Y,Z), fromList([1,2,3],X), fromList([4,5],Y), toList(Z, Final).
\end{minted}
}

\Curry{
\begin{minted}{haskell}
dconcat x y z & fromList [1,2,3] x & fromList [4,5] y & toList z final
   where x, y, z, final free
\end{minted}
}

should produce:

\begin{verbatim}
...
final = [1,2,3,4,5]
\end{verbatim}

\begin{ans}
~
\begin{minted}{prolog}
dconcat(d(Out2,In2),d(Out1,In1),d(Out,In)) :- Out = Out2, In2 = Out1, In = In1.
\end{minted}
or
\begin{minted}{prolog}
dconcat(d(Out,Intermediate),d(Intermediate,In),d(Out,In)).
\end{minted}
\end{ans}

\end{ex}

\begin{question}{***}
What happens when you concatenate a difference list with itself?
\begin{ans}
The difference list will contain circular, infinite lists.
\end{ans}
\end{question}





\subsection{Functions ↔ Relations}

Consider the following haskell function, that splits a list of
integers into two lists: one containing the positive ones (and zero),
the other containing the negative ones.
\begin{verbatim}
split [] = ([],[])
split (x:xs) | x >= 0 = (x:p,n)
             | x <  0 = (p,x:n)
  where (p,n) = split xs
\end{verbatim}

If written as a predicate, it is natural if it takes 3 arguments. For example,

\begin{verbatim}
split([3,4,-5,-1,0,4,-9],p,n)
\end{verbatim}

should bind:

\begin{verbatim}
P = [3,4,0,4]
N = [-5,-1,-9].
\end{verbatim}


\begin{question}{**}
  Write the predicate \textsf{split}. Make sure that it is \emph{reversible}. That is,
  you can recover the original list if you pass it the split lists.
  \begin{ans}

    \begin{minted}{prolog}
      split([],[],[]).
      split([X|A],[X|P],N) :- X >= 0, split(A,P,N).
      split([X|A],P,[X|N]) :- X <  0, split(A,P,N).
    \end{minted}
  \end{ans}
\end{question}

\begin{question}{**}
    What are the lists that are returned by \textsf{split/3} when used in reverse? Can it fail?
    \begin{ans}
      All the possible interleavings of the inputs. If a number of the wrong class is
      in either of the inputs, it will fail.
    \end{ans}
\end{question}

\subsection{Explicit Search}


Consider the following list comprehension, in Haskell syntax:
\begin{verbatim}
c = [f x | z <- a, y <- g z, x <- h y, p v]
\end{verbatim}

\begin{ex}{*}
  Write down possible types for f, a, g, h and p.
\end{ex}

\begin{ex}{*}
  Assume that the above functions/values (f, a, g, h and p) are
  translated to relational style. What would be natural types for
  them?
\end{ex}

\begin{ex}{*}
  Translate the list comprehension to relational style.
\end{ex}

\begin{ex}{**}
  Translate all the functions from Family.curry in the ``list of
  successes'' style, for all directions.
\end{ex}




\end{document}
