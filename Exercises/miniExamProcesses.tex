\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{minted}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}

\usepackage{pgf, tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows}


\newcommand{\Blue}[1]{\color{blue}#1\color{black}\xspace}

\usepackage{array}
% This is needed because raggedright in table elements redefines \\:
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\let\PBS=\PreserveBackslash

%%%%%%%%%%%%%%
\newcommand{\solution}[1] {}
%\newcommand{\solution}[1] {\textbf{Solutions:}\\ #1}

%\newcommand{\comment}[1]{}
\newcommand{\answer}[0]{\paragraph{Answer:}}
% \newcommand{\answer}[1]{}
\newcommand{\comment}[1]{\marginpar{#1}}

\newcommand{\points}[1]{\marginpar{\bf #1 points}}

\begin{document}

\section{Variable-managing process}

Assume a language without pointers nor variables, but support for
concurrency. In particular, assume primitives for creating processes
and channels, and primitives for reading and writing to to
channels. For example C++-style:

\begin{minted}{cpp}
Chan<A> newChan();
A readChan(Chan<A> c);
void writeChan(Chan<A> c,A x);
void forkProcess(*void());
\end{minted}
or Haskell-style:
\begin{minted}{haskell}
newChan :: IO (Chan a)
readChan :: Chan a -> IO a
writeChan :: Chan a -> a -> IO ()
forkProcess :: IO () -> IO ()
\end{minted}

Your task is to simulate references to mutable variables using the
above primitives. This can be done be using a process that manages the
variable state.

\begin{enumerate}
\item Define the representation for a variable of type ``reference to
  Integer''. Name this type \texttt{Reference}. \points 3
\item Write the code for the process that manages the variable state. \points 4
\item Write the code for primitives to create, read and write references. \points 3
Their type should be:
\begin{minted}{cpp}
Reference newRef();
int readRef(Reference);
void writeRef(Reference, int);
\end{minted}
or Haskell-style:
\begin{minted}{haskell}
newRef :: IO Reference
readRef :: Reference -> IO Int
writeRef :: Reference -> Int -> IO ()
\end{minted}
\end{enumerate}

Hint: The channels can transmit any type of information, including
references to channels.

Remark: You can use either a functional or imperative language to
write your answer, however you may not use any global variable nor
primitive reference types in it.

\section{Continuations and Closures}

Replace lambda abstractions by explicit closures in the following
code. \points{10}
\begin{minted}{haskell}
data Tree a = Leaf | Bin (Tree a) a (Tree a)

traverseC :: Tree Int -> (Int -> Int) -> Int
traverseC Leaf k = k 0
traverseC (Bin l x r) k =
  traverseC l (\tl ->
  traverseC r (\tr ->
  k (tl + x + tr)))

traverse t = traverseC t (\x -> x)
\end{minted}

\end{document}
