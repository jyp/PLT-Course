\documentclass{article}
\usepackage{fancyvrb,hyperref,listings}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}

\lstset{language=java,basicstyle=\small}
\lstset{commentstyle=\textit,flexiblecolumns=true,mathescape=true}
\lstnewenvironment{java}
    {\lstset{language=java,frame=tb}}
    {}
\lstnewenvironment{cplus}
    {\lstset{language=c++,frame=tb}}
    {}
\lstnewenvironment{perl}
    {\lstset{language=perl,mathescape=false,lineskip=0\baselineskip,frame=tb}}
    {}

\include{fortify-macros}

\newcommand{\percent}[1]{\protect \marginpar[l]{\bf [#1 points]}}
\newcounter{question}
\newenvironment{question}[1]{%
  \addtocounter{question}{1}%
  \paragraph{Exercise~\arabic{question}  \percent{#1}}%
}{%
  \vskip1em%
}

\newenvironment{longanswer}{\paragraph{Answer~\arabic{question}}}{}
\newcommand{\answer}[1]{\begin{longanswer}#1\end{longanswer}}
  

\begin{document}

\title{Exercises on Imperative Programming\\
  \large Programming Paradigms}
\author{Sibylle Schupp}
\maketitle


\section{Parameter passing \percent{9}}

\begin{question}{5}
Determine the final values of the array \textsf{A} after the call to
\textsf{f} for each of the parameter-passing mechanisms: call-by-value,
call-by-name, call-by-reference, call-by-result, call-by-value-result.
(Assume left to right evaluation of parameters and early location 
computation for by-result and by-value-result.)

\vfil\noindent\begin{minipage}[b]{0.5\linewidth}
\begin{java}
void f(int x, int y) {
    x = 1;
    y = 3;
}
\end{java}%
\end{minipage}%
\begin{minipage}[b]{0.5\linewidth}%
\begin{java}
int[] A = new int[2];
A[0] = 0;
A[1] = 2;
f(A[0],A[A[0]]);
\end{java}%
\end{minipage}%
\answer{
  \begin{tabular}[t]{lll}
                   & A[0] & A[1] \\
   by-reference    & 3    & 2    \\
   by-value        & 0    & 2    \\
   by-result       & 3    & 2    \\
   by-value-result & 3    & 2    \\
   by-name         & 1    & 3    \\
  \end{tabular}
}%
\end{question}

An important question of call-by-result, which was not discussed in
class, is the question \textit{when} the location of the actual parameter is 
computed. One might expect that this happens before the callee executes,
but that is not necessarily the case---since the value of the actual
parameter is not needed until the 
callee returns, its computation could be delayed until the value is needed.
Ada, for example,  supports early location-computation, while Algol-W implements
late location-computation.

\begin{question}{2}
Use the snippet below to explain the difference between early and late
location-computation.
\vfil\noindent\begin{minipage}[b]{0.45\linewidth}
\begin{java}
void f(int [] A) {
   int i = 0;
   g(i, A[i]);
   // What happens to i and A?
}

\end{java}%
\end{minipage}%
\begin{minipage}[b]{0.55\linewidth}
\begin{java}
void g(by-reference int i, by-result int j) {
   j = 2;
   i = 1;
   j = 3;
}
\end{java}%
\end{minipage}%
\answer{
  \begin{tabular}[t]{lll}
            & A[0] & A[1] \\
    early   & 3    & ?    \\
    late    & ?    & 3    \\
  \end{tabular}
}%
\end{question}

%\begin{question}{X}{
% When does C\# perform the location-computation for its by-result parameters?
%\end{question}

Another important detail of call-by-result and call-by-value-result concerns
the order in which the final values of the formal parameter are written back
to the actual parameters. For a binary method \textsf{f(x,y)}, for
example, either (the value of) \textsf{x} or (the value of) 
\textsf{y} is written back
first; this order might make a difference. 

\begin{question}{2}
Write (in pseudo-code, if you wish) a function \textsf{f} that calls a
function \textsf{g} to demonstrate the difference.
\begin{longanswer}
See the following example:\\
\vfil\noindent\begin{minipage}[b]{0.5\linewidth}
\begin{java}
void f(int x, int y) {
  x = 4;
  y = 5;
}
\end{java}%
\end{minipage}%
\begin{minipage}[b]{0.5\linewidth}%
\begin{java}
void g() {
  int a=3;
  f(a,a); 
}
\end{java}%
\end{minipage}%
\end{longanswer}%
\end{question}


\section{Activation records and scoping \percent{7}}
The \textit{scope} of a variable declaration refers to the range of
statements in which the variable can be referenced. 
\begin{itemize}
\item In \textit{static scoping}, the use of a variable $y$ in
a subprogram $f$ refers to the declaration of $y$ at the beginning of $f$ 
or, if not
declared there, to the declaration of $y$ in the subprogram $g$ 
whose declaration
contains the declaration of $f$, and so on. The static scope, thus,
is a property of the program text and can be determined at compile time.
\item In \textit{dynamic scoping}, on the other hand, 
the scope depends on the call sequence of
subroutines: the use of a variable refers to the declaration in 
the nearest caller (``dynamic parent'').
\end{itemize}

\begin{question}{3}
  In dynamic scoping, it is easy for the run-time system to determine
  which declaration the use of a variable refers to. Explain using the
  run-time stack.
\answer{
  Traverse the run-time stack, take the first matching declaration encountered.
}
\end{question}

Static scoping with non-local references, on the other hand, is not so
easy to implement. In particular, the kind of activation records
discussed in class (which contain only two kinds of internal
information: the return address and the previous activation record)
does not suffice.

\begin{question}{3}
What additional information is necessary and where could it be stored?
Make a suggestion and sketch a (simple) algorithm that takes a
run-time stack and an activation record, and returns the ``right''
reference (or at least its activation record).
\answer{
Include in the activation record a  ``static link'' (a.k.a. access links),
then follow the link to the static parent, and find a matching declaration
as in the dynamic case.

For a solution in constant time: compute the ``static distance'' between
a variable definition and a variable reference.
}%
\end{question}

Java, C, \Cpp, C\#, and most other languages support static scoping. The
language Perl is special since it gives the user control: variables
declared as \textsf{`my'} are statically scoped, variables declared as
\textsf{'local'} are dynamically scoped.

\begin{question}{1}
  What is the effect of static and dynamic scoping? Consider the Perl
  program below and vary between \textsf{my} and \textsf{local} for the
  three declarations of $x$. When, if at all, will $1$, $4.14$, and $56$
  be printed? Explain how each value is obtained and why?
\answer{
  Pattern matching on the modifiers:\\
  \begin{tabular}{ll}
    outer/p/q      & result   \\ \hline
    */my/my        & $x=1$    \\
    local/*/local  & $x=4.14$ \\
    local/local/my & $x=56$   \\
    */*/*          & error
  \end{tabular}
}
\end{question}

\paragraph{Hint:}
Perl is installed on (almost) all machines; you can run the program.

\pagebreak

\begin{perl}
 sub outer {
   my $x = 0;

   sub r(){
       $x = $x + 1; 
       print("In subroutine r, x = ", $x);
   }
   sub q() {
      my $x = 3.14; 
      &r;      # call outer's subroutine r
   }
   sub p() {
      my $x = 55; 
      &q;      # call outer's subroutine q
   } 
   &p;         # call subroutine p
}
&outer;
\end{perl}

\section{Duff's device \percent{4}}
Duff's device is an optimization idiom for serial copies 
in the language C. The fragment below lists first the original code,
then Duff's optimization.
\begin{cplus}
/* (Almost) original code */
int main() {
   short *to, *from;
   int count;	
   ... 
   {
     /* pre: count > 0 */		
     do
	  *to++ = *from++;		
     while(--count>0);	
   }
   return 0; 
}
\end{cplus}

\begin{question}{1}
What happens in the assignment ``\textsf{*to++ = *from++;}''?  Explain in
terms of pointers and values pointed to. Draw a picture if necessary.
\answer{
  It is equivalent to \texttt{*to = *from; to++; from++;}.
  In other words, the memory pointed by \texttt{from} is copied to the memory pointed by \texttt{to}, then the pointers are incremented.
}
\end{question}

\pagebreak

\begin{cplus}
/* Duff's transformation */
int main() {
  short *to, *from;
  int count;	
  ...
  {
     /* pre: count > 0 */		
     int n = (count + 7) / 8;
     switch(count % 8){
       case 0:	do{	*to++ = *from++;
       case 7:	        *to++ = *from++;
       case 6:	        *to++ = *from++;
       case 5:	        *to++ = *from++;
       case 4:	        *to++ = *from++;
       case 3:	        *to++ = *from++;
       case 2:	        *to++ = *from++;
       case 1:	        *to++ = *from++;
                } while (--n > 0);
     }
  }
  return 0;
}
\end{cplus}
% Explain pointer variables in terms of r-values and l-values: what is the r-value of a pointer?

Furthermore, look up what the \textsf{switch} statement does (preferably
in the language specification). Why is the second program is equivalent
to the first?

\newcommand{\floor}[1]{\lfloor #1 \rfloor}

\begin{question}{2}
Show that the instruction ``\texttt{*to++ = *from++}'' will be executed 
\texttt{count} times in the second program.
\answer{The while loop will be executed $\floor{(count + 7) / 8}$ times.
Since each iteration executes the instruction 8 times, we expect the
program to run it $8 \times \floor{(count + 7)/ 8}$ times in total, which
is up to 7 times more than count. 

However, the \texttt{switch} instruction is there to skip 
$count \bmod 8$ instructions in \emph{the first iteration}, to
make the count exact.
 }
\end{question}

Why did Duff expect the second program to be faster?

\begin{question}{1}
  What instructions are executed in the first program but
  not in the second?  
  
  \answer{The test and jump instructions are executed only $\floor{(count + 7) / 8}$ times instead of $count$,
          which about $1/8$ of the time.}
\end{question}


\paragraph{Further reading}
\begin{itemize}
\item For the original email in which Tom Duff presented his ``device'',
see 

\url{http://www.lysator.liu.se/c/duffs-device.html}
\item The specification of the C language is available at 

\url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf}
\item Check the generated code yourself: compile it
with \textsf{gcc -S $<$filename$>$}.
\end{itemize}


\section{Hello, Fortress \percent{5}}
Among the recent languages is the language \textsf{Fortress}, developed
by Sun within the \textsf{High Productivity Computer Systems (HPCS)}
competition by the US goverment. It is a general-purpose language but has
features---built-in support for parallelism, for example---that make it
interesting for scientific computing and high-performance computations.
Although \textsf{Fortress} has been around for a few years, its
specification (v.1.0) has been published only this year. The purpose of
this exercise is to expose you to language specifications (and the
challenges of language development). As example, we use a method from one
of the Fortress tutorials for computing the conjugate gradient:
%

\begin{Fortress}
\(\VAR{conjGrad}\llbracket\,\null\)\pushtabs\=\+\(\TYP{Elt} \KWD{extends}\:\TYP{Number}, \KWD{nat}\:N,\)\\
\(          \TYP{Vec} \KWD{extends}\:\TYP{Vector}\llbracket\TYP{Elt},N\rrbracket,\)\\
\(          \TYP{Mat} \KWD{extends}\:\TYP{Matrix}\llbracket\TYP{Elt},N,N\rrbracket\rrbracket\)\-\\\poptabs
{\tt~~~~~~~~}\pushtabs\=\+\(        (A\COLON \TYP{Mat}, x\COLON \TYP{Vec})\COLON (\TYP{Vec}, \TYP{Elt}) = \;\KWD{do}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \VAR{cgit{\tt\_}max} = 25\)\\
\(  z\COLON \TYP{Vec} \ASSIGN x.\VAR{replica}\llbracket\TYP{Elt}\rrbracket().\VAR{fill}(0)\)\\
\(  r\COLON \TYP{Vec} \ASSIGN x\)\\
\(  p\COLON \TYP{Vec} \ASSIGN r\)\\
\(  \rho{}\COLON \TYP{Elt} \ASSIGN r \cdot r\)\\
\(  \KWD{for}\:j \leftarrow \VAR{seq}(1\mathinner{\hbox{\tt\char'43}}\VAR{cgit{\tt\_}max}) \KWD{do}\)\\
{\tt~~}\pushtabs\=\+\(    q = A\:p\)\\
\(    \alpha{} = \rho{} / (p \cdot q)\)\\
\(    z \mathrel{+}= \alpha{}\:p\)\\
\(    \rho{}_{0} = \rho{}\)\\
\(    r \mathrel{-}= \alpha{}\:q\)\\
\(    \rho{} \ASSIGN r \cdot r\)\\
\(    \beta{} = \rho{} / \rho{}_{0}\)\\
\(    p \ASSIGN r + \beta{}\:p\)\\
\(    \VAR{println}(\hbox{\rm``\STR{Iter~}''}\;\;j\;\;\hbox{\rm``\STR{~alpha~=~}''}\;\;\alpha{} //\;\;\hbox{\rm``\STR{z}''}\;\;z)\)\-\\\poptabs
\(  \KWD{end}\)\\
\(  (z, \left\|x - A\:z\right\|)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}


Download the current language specification and answer the
following questions:
\begin{question}{1}
  What is the difference between the \textit{reach} and the
  \textit{scope} of a declaration? Look up the language specification, then give
  a definition in your own words (no more than 40 words). Use the \textsf{conjGrad}
  example above to illustrate the
  two terms.
\answer{
The reach is the lexically enclosing block.
The scope is where the declared entity can actually be used.
  }
\end{question}

\begin{question}{1}
Explain the difference of the following variable
declarations in terms of mutability and initialization and, again,
use the \textsf{conjGrad} example above for illustration:
\[
\begin{tabular}{c}
x = e \\
x: T = e  \\
\mbox{var\ } x: T = e\\
x: T := e\\
(x,y) = (e,f)
\end{tabular}
\]
\answer{
  \begin{tabular}{ll}
    mutable & initial value \\
    \hline
    no      & e             \\
    no      & e             \\
    yes     & e             \\
    yes     & e             \\
    no      & respectively e f
  \end{tabular}
}
\end{question}

\begin{question}{1}
Consider the signature of the method \textsf{conjGrad}, which consists of
three parameter lists, namely $\llbracket\ldots\rrbracket$, $(\ldots)$,
and $(\ldots)$. Which part refers to program parameters that must be
passed at run time?
\answer{($A$:Mat, $x$:Vec)}

\end{question}

\begin{question}{1}
Which parameter-passing mechanism(s) does \textsf{Fortress} support, and
if there is more than one, which one applies here? Back your answer with
a reference to the language specification.
\answer{
call-by-value, 13.6
}
\end{question}

For-loops in Fortress are specified as follows (13.5):
\begin{quote}
A \textsf{for} loop consists of \textsf{for} followed by a generator 
clause list (discussed in Section 13.14), followed by a non-parallel 
do expression (the loop body; see Section 13.11). 
Parallelism in \textsf{for} loops is specified by the generators 
used (see Section 13.14); in general the programmer must assume that 
each loop iteration will occur independently 
in parallel unless every generator is explicitly sequential. 
For each iteration, the body expression is evaluated in the 
scope of the values bound by the generators. The value and type of a 
\textsf{for} loop is () . 
\end{quote}

\begin{question}{1}
Explain how the \textsf{for}-loop in the \textsf{conjGrad} method
works: what is the ``generator clause list''; what is the generator;
what does it mean that ``the body expression is evaluated in the scope of
the values bound by the generators''; and in which
order are values generated? 
\answer{
Reading section 13.15.
\begin{itemize}
\item Generator clause list: $j \leftarrow seq(1 \# mbox{\
    cgit\_max})$ (there is only one generator in the list in this
  case).
  \item Generator: $j \leftarrow seq(1\#\mbox{cgit\_max})$
  \item ``The body expression is evaluated in the scope of the values
    bound by the generators'' means that $j$ can be used in the body of
    the loop.
  \item In which order are values generated? Sequentially. See the $seq$ (explained in 13.14).
\end{itemize}
}
\end{question}

\paragraph{Further reading}
\begin{itemize}
\item The main project page: \\
\indent\url{http://projectfortress.sun.com/Projects/Community}
\item The language specification: \\
\indent\href{http://projectfortress.sun.com/Projects/Community/browser/trunk/Specification/fortress.1.0.pdf}{\nolinkurl{.../browser/trunk/Specification/fortress.1.0.pdf}}
\item The current interpreter binary: \\
\indent\href{http://projectfortress.sun.com/Projects/Community/downloads/7}{\nolinkurl{.../downloads/7}}
\item Source-code for \textsf{conjGrad}: \\
\indent\href{http://projectfortress.sun.com/Projects/Community/browser/trunk/ProjectFortress/demos/conjGrad.fss}{\nolinkurl{.../browser/trunk/ProjectFortress/demos/conjGrad.fss}}
\end{itemize}

\vfill

\end{document}