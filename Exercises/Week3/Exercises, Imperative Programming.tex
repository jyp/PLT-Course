\documentclass{article}
\usepackage{fancyvrb,hyperref,listings}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}
\newcommand{\cpp}{\Cpp}
\newcommand{\mycomment}[1]{}

\lstset{language=java,basicstyle=\small}
\lstset{commentstyle=\textit,flexiblecolumns=true,mathescape=true}
\lstnewenvironment{java}
    {\lstset{language=java,frame=tb}}
    {}
\lstnewenvironment{java2}
    {\lstset{language=java}}
    {}
\lstnewenvironment{cplus}
    {\lstset{language=c++,frame=tb}}
    {}
\lstnewenvironment{cplus2}
    {\lstset{language=c++}}
    {}
\lstnewenvironment{perl}
    {\lstset{language=perl,mathescape=false,lineskip=0\baselineskip,frame=tb}}
    {}

\include{fortify-macros}

\newcommand{\percent}[1]{\protect \marginpar[l]{\bf [#1 points]}}
\newcounter{question}
\newenvironment{question}[1]{%
  \addtocounter{question}{1}%
  \paragraph{Exercise~\arabic{question}  \percent{#1}}%
}{%
  \vskip1em%
}
\newcommand{\answer}[1]{
  \paragraph{Answer~\arabic{question} } #1
}
  

\begin{document}

\title{Exercises on Imperative Programming\\
  \large Programming Paradigms}
\author{Sibylle Schupp}
\maketitle


\section{Parameter passing \percent{25}}

\begin{question}{X}
For each of the following parameter passing mechanisms,
determine the final values of the array \textsf{A} after the call
to \textsf{f}. 

Types: call-by-value, call-by-name, call-by-reference, call-by-result,
call-by-value-result. Assume left to right evaluation of parameters
and early lvalue computation.

\vfil\noindent\begin{minipage}[b]{0.5\linewidth}
\begin{java}
void f(int x, int y) {
    x = 1;
    y = 3;
}
\end{java}
\end{minipage}

\begin{minipage}[b]{0.5\linewidth}
\begin{java}
int[] A = new int[2];
A[0] = 0;
A[1] = 2;
f(A[0],A[A[0]]);
\end{java}
\end{minipage}
\end{question}

An important question of call-by-result, which was not discussed in
class, is the question \textit{when} the lvalue of the actual parameter is 
computed. One might expect that this happens before the callee executes,
but that is not necessarily the case---since the value of the actual
parameter is not needed until the 
callee returns, its computation could be delayed until the value is needed.
Ada, for example,  supports early lvalue-computation, while Algol-W implements
late lvalue-computation.

\begin{question}{X}
Use the snippet below to explain the difference between early and late
lvalue-computation.
\vfil\noindent\begin{minipage}[b]{0.45\linewidth}
\begin{java}
void f(int [] A) {
   int i = 0;
   g(i, A[i]);
   // What happens to i and A?
}

\end{java}%
\end{minipage}%
\begin{minipage}[b]{0.55\linewidth}
\begin{java}
void g(by-reference int i, by-result int j) {
   j = 2;
   i = 1;
   j = 3;
}
\end{java}%
\end{minipage}%
\end{question}

%\begin{question}{X}{
% When does C\# perform the lvalue-computation for its by-result parameters?
%\end{question}

Another important detail of call-by-result and call-by-value-result concerns
the order in which the final values of the formal parameter are written back
to the actual parameters. For a binary method \textsf{f(x,y)}, for
example, either (the value of) \textsf{x} or (the value of) 
\textsf{y} is written back
first; this order might make a difference. 

\begin{question}{X}
Write two methods \textsf{f,g} (in pseudo-code,
if you wish) that demonstrate the difference.
\end{question}


\section{Activation records and scoping \percent{25}}
The \textit{scope} of a variable declaration refers to the range of
statements in which the variable can be referenced. 
\begin{itemize}
\item In \textit{static scoping}, the use of a variable $y$ in
a subprogram $f$ refers to the declaration of $y$ at the beginning of $f$ 
or, if not
declared there, to the declaration of $y$ in the subprogram $g$ 
whose declaration
contains the declaration of $f$, and so on. The static scope, thus,
is a property of the program text and can be determined at compile time.
\item In \textit{dynamic scoping}, on the other hand, 
the scope depends on the call sequence of
subroutines: the use of a variable refers to the declaration in 
the nearest caller (``dynamic parent'').
\end{itemize}
Java, C, \Cpp, C\#, and most other
 languages support static scoping. The language Perl is special
since it gives the user control: 
variables declared as \textsf{`my'} are statically scoped, 
variables declared as \textsf{'local'} are dynamically scoped.  

\mycomment{
In this exercise, the question is: given a particular  use of
a variable, how does the run-time system know which declaration that 
variable refers to? As discussed in class, activation records contain
only two kinds of internal information: the return address and the previous
activation record. This does not suffice for languages with
static scoping and \textit{non-local variable references}.
}

\begin{question}{0}
  What is the effect of static and dynamic scoping? Consider the Perl
  program below and vary between \textsf{my} and \textsf{local} for the
  three declarations of $x$. When, if at all, will $2$, $4.14$, and $56$
  be printed? Explain how each value is obtained and why?
\end{question}

\paragraph{Hint:}
Perl is installed on (almost) all machines; you can run the program.

\begin{perl}
 sub outer {
   my $x = 0;

   sub r(){
       $x = $x + 1; 
       print("In subroutine r, x = ", $x);
   }
   sub q() {
      my $x = 3.14; 
      &r;      # call outer's subroutine r
   }
   sub p() {
      my $x = 55; 
      &q;      # call outer's subroutine q
   } 
   &p;         # call subroutine p
}
&outer;
\end{perl}

\begin{question}{X}
  In dynamic scoping, it is easy for the run-time system to determine
  which declaration the use of a variable refers to. Explain using the
  run-time stack.  
\end{question}

\mycomment{
Static scoping with non-local references, on the other hand,
is not so easy to implement. In particular, the kind of 
activation records discussed in class (which contain
only two kinds of internal information: the return address and the previous
activation record) does not suffice. 
%

What information would be necessary and where could it be stored? 
Make a suggestion  and 
sketch a (simple) algorithm that takes a run-time stack and an activation record,
and returns the ``right'' reference (or at least its activation record).
How expensive is your algorithm? Determine the parameters on which its
cost depends and give the cost of the algorithm.
}


\newpage 
\section{Duff's device [25p]}
Duff's device is an optimization idiom for serial copies 
in the language C. The fragment below lists first the original code,
then Duff's optimization.
\begin{cplus}
/* (Almost) original code */
int main() {
   short *to, *from;
   int count;	
   ... 
   {
     /* pre: count > 0 */		
     do
	  *to++ = *from++;		
     while(--count>0);	
   }
   return 0; 
}

\end{cplus}

\begin{cplus}
/* Duff's transformation */
int main() {
  short *to, *from;
  int count;	
  ...
  {
     /* pre: count > 0 */		
     int n = (count + 7) / 8;
     switch(count % 8){
       case 0:	do{	*to++ = *from++;
       case 7:	        *to++ = *from++;
       case 6:	        *to++ = *from++;
       case 5:	        *to++ = *from++;
       case 4:	        *to++ = *from++;
       case 3:	        *to++ = *from++;
       case 2:	        *to++ = *from++;
       case 1:	        *to++ = *from++;
                } while (--n > 0);
     }
  }
  return 0;
}
\end{cplus}
% Explain pointer variables in terms of r-values and l-values: what is the r-value of a pointer?

\begin{question}{X}
What happens in the assignment ``\textsf{*to++ = *from++;}''?  Explain in
terms of pointers and values pointed to. Draw a picture if necessary.
\answer{
  It is equivalent to \texttt{*to = from*; to++; from++;}.
  In other words, the memory pointed by \texttt{from} is copied to the memory pointed by \texttt{to}, then the pointers are incremented.
}
\end{question}

Furthermore, look up what
the \textsf{switch} statement does (preferably in the language
specification). Why isthe second program is equivalent to the first?

\newcommand{\floor}[1]{\lfloor #1 \rfloor}

\begin{question}{X}
Show that the instruction \texttt{*to++ = *from++} will be executed 
\texttt{count} times in the second program.
\answer{The while loop will be executed $\floor{(count + 7) / 8}$ times.
Since each iteration executes the instruction 8 times, we expect the
program to run it $8 \times \floor{(count + 7) / 8}$ times in total, which
is up to 7 times more than count. 

However, the \texttt{switch} instruction is there to skip 
$count \bmod 8$ instructions in \emph{the first iteration}, to
make the count exact.
 }
\end{question}

Why did Duff expect the second program to be faster?

\begin{question}{X}
  What are the instructions that are executed in the first program but
  not in the second?  
  
  \answer{The jump instructions are executed only $1/8^{th}$ of the
    time on average.}
\end{question}


\paragraph{Further reading}
\begin{itemize}
\item For the original email in which Tom Duff presented his ``device'',
see 

\textsf{http://www.lysator.liu.se/c/duffs-device.html}
\item The specification of the C language is available at 

\textsf{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf}
\item Check the generated code yourself: compile it
with \textsf{gcc -S $<$filename$>$}.
\end{itemize}


\section{Hello, Fortress \percent{25}}
Among the recent languages is the language \textsf{Fortress}, developed
by Sun within the \textsf{High Productivity Computer Systems (HPCS)}
competition by the US goverment. It is a general-purpose language but has
features---built-in support for parallelism, for example---that make it
interesting for scientific computing and high-performance computations.
Although \textsf{Fortress} has been around for a few years, its
specification (v.1.0) has been published only this year. The purpose of
this exercise is to expose you to language specifications (and the
challenges of language development). As example, we use a method from one
of the Fortress tutorials for computing the conjugate gradient:
%

\begin{Fortress}
\(\VAR{conjGrad}\llbracket\,\null\)\pushtabs\=\+\(\TYP{Elt} \KWD{extends}\:\TYP{Number}, \KWD{nat}\:N,\)\\
\(          \TYP{Vec} \KWD{extends}\:\TYP{Vector}\llbracket\TYP{Elt},N\rrbracket,\)\\
\(          \TYP{Mat} \KWD{extends}\:\TYP{Matrix}\llbracket\TYP{Elt},N,N\rrbracket\rrbracket\)\-\\\poptabs
{\tt~~~~~~~~}\pushtabs\=\+\(        (A\COLON \TYP{Mat}, x\COLON \TYP{Vec})\COLON (\TYP{Vec}, \TYP{Elt}) = \;\KWD{do}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \VAR{cgit{\tt\_}max} = 25\)\\
\(  z\COLON \TYP{Vec} \ASSIGN x.\VAR{replica}\llbracket\TYP{Elt}\rrbracket().\VAR{fill}(0)\)\\
\(  r\COLON \TYP{Vec} \ASSIGN x\)\\
\(  p\COLON \TYP{Vec} \ASSIGN r\)\\
\(  \rho{}\COLON \TYP{Elt} \ASSIGN r \cdot r\)\\
\(  \KWD{for}\:j \leftarrow \VAR{seq}(1\mathinner{\hbox{\tt\char'43}}\VAR{cgit{\tt\_}max}) \KWD{do}\)\\
{\tt~~}\pushtabs\=\+\(    q = A\:p\)\\
\(    \alpha{} = \rho{} / (p \cdot q)\)\\
\(    z \mathrel{+}= \alpha{}\:p\)\\
\(    \rho{}_{0} = \rho{}\)\\
\(    r \mathrel{-}= \alpha{}\:q\)\\
\(    \rho{} \ASSIGN r \cdot r\)\\
\(    \beta{} = \rho{} / \rho{}_{0}\)\\
\(    p \ASSIGN r + \beta{}\:p\)\\
\(    \VAR{println}(\hbox{\rm``\STR{Iter~}''}\;\;j\;\;\hbox{\rm``\STR{~alpha~=~}''}\;\;\alpha{} //\;\;\hbox{\rm``\STR{z}''}\;\;z)\)\-\\\poptabs
\(  \KWD{end}\)\\
\(  (z, \left\|x - A\:z\right\|)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}


Download the current language specification and answer the
following questions:
\begin{question}{X}
  What is the difference between the \textit{reach} and the
  \textit{scope} of a declaration? Look up the language specification, then give
  a definition in your own words (no more than 40 words). Use the \textsf{conjGrad}
  example above to illustrate the
  two terms.
\answer{
The reach is the lexically enclosing block.
The scope is where the declared entity can actually be used.
  }
\end{question}

\begin{question}{X}
  
Explain the difference of the following variable
declarations in terms of mutability and initialization and, again,
use the \textsf{conjGrad} example above for illustration:
\[
\begin{array}{l}
x = e \\
x: T = e  \\
\mbox{var\ } x: T = e\\
x: T := e\\
(x,y) = (e,f)
\end{array}
\]

\end{question}

\begin{question}{X}
Consider the signature of the method \textsf{conjGrad}, which
consists of 3 parameter lists, namely [...], (..), and (..). Which part
refers to program parameters that must be passed at run time?
Which parameter-passing mechanism(s) does \textsf{Fortress}
support, and if there is more than one,  which one applies here?
Back your answer with a reference to the language specification.
% so that we know that you are not just guessing, you brats.
\end{question}

\begin{question}{X}
For-loops in Fortress are specified as follows (13.5):
\begin{quote}
A \textsf{for} loop consists of \textsf{for} followed by a generator 
clause list (discussed in Section 13.14), followed by a non-parallel 
do expression (the loop body; see Section 13.11). 
Parallelism in \textsf{for} loops is specified by the generators 
used (see Section 13.14); in general the programmer must assume that 
each loop iteration will occur independently 
in parallel unless every generator is explicitly sequential. 
For each iteration, the body expression is evaluated in the 
scope of the values bound by the generators. The value and type of a 
\textsf{for} loop is () . 

\end{quote}
Explain how the \textsf{for}-loop in the \textsf{conjGrad} method
works: what is the ``generator clause list''; what is the generator;
what does it mean that ``the body expression is evaluated in the scope of
the values bound by the generators''; and in which
order are values generated? 

\end{question}

\vfill

\end{document}