\documentclass{beamer}

\beamertemplatenavigationsymbolsempty


\mode<presentation>
{
\usetheme[width=0cm]{Goettingen}
\usecolortheme{seahorse}
\useoutertheme{SEFM}
}

\input{header}
\usepackage[english]{babel}
% or whatever

\usepackage[utf8x]{inputenc}

\usepackage{times}
\usepackage[T1]{fontenc}

% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\usepackage{pgf,tikz}
\usetikzlibrary{decorations}
\usetikzlibrary{shapes.arrows}
\usepackage{url}
\usepackage{listings}

\lstdefinelanguage{FSharp}
      {morekeywords={let, new, match, inherit, abstract, with, rec,
          open, module, namespace, type, of, member, and, for, in, do,
          begin, end, fun, function, try, mutable, if, then, else,
          class, interface, end},
    keywordstyle=\color{blue},
    basicstyle = \small,
    sensitive=false,
    morecomment=[l][\color{green!50!black!80}]{///},
    morecomment=[l][\color{green!50!black!80}]{//},
    morecomment=[s][\color{green!50!black!80}]{{(*}{*)}},
    morestring=[b]",
    stringstyle=\color{red},
    columns=fullflexible
    }


\lstdefinelanguage{Smalltalk}{
  basicstyle=\ttfamily,
  keywordstyle=\bfseries,
  morekeywords={self,super,true,false,nil,thisContext}, % This is overkill
  morestring=[d]',
  morecomment=[s]{"}{"},
  alsoletter={\#:},
  escapechar={!},
}[keywords,comments,strings]

\lstset{language=FSharp}

\newcommand{\Blue}[1]{\color{blue}#1\color{black}\xspace}

\title[]{Object-Oriented Programming}

\subtitle[F\#]{F\#: A Multi-Paradigm Language} %
%{OOP} % (optional)


\author[Richard Bubel] % (optional, use only with lots of authors)
{Richard Bubel}

\institute[CTH]{Chalmers University of Technology}

\date{25th November 2010}%[Short Occasion] % (optional)


\subject{Talks}
% This is only inserted into the PDF information catalog. Can be left
% out.



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

%\pgfdeclareimage[height=0.5cm]{university-logo}{../../../project/gitroot/clipart/ChalmGUmarke.pdf}
% \logo{\pgfuseimage{university-logo}}


\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Facts}

\Blue{F\# is tightly integrated into Microsofts \textsf{.net} framework}

\bigskip

\Blue{\textsf{.net} framework is object-oriented and provides a huge standard API}

\bigskip

\Blue{F\# incorporates the functional as well as the object-oriented
paradigm to integrate well in the common framework.}

\bigskip\bigskip

Material and Language Reference at:

{\small \url{http://msdn.microsoft.com/en-us/library/dd233154.aspx}}

\end{frame}

\section{Functional Concepts}

\begin{frame}[fragile]{Variable Definition}
\begin{lstlisting}[language=FSharp, escapechar=\%]
  let %\textit{var-name [}% : %\textit{type]}% = %\textit{expression}%

%Examples:%

  let x = 10
  let input = Console.ReadLine()

\end{lstlisting}
  
\begin{itemize}
\item Variables defined as above are immutable
\item Type if possible automatic inferred
\item Eager evaluation of expressions (lazy supported but not enabled
  by default; keyword \lstinline!lazy!)
\item Seamless integration in \texttt{.net} framework, e.g.,
  \lstinline!let dir = new System.IO.DirectoryInfo(@"/Users/bubel")!

 
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Function Definitions}
\begin{lstlisting}[language=FSharp, escapechar=\%]
 let %\textit{[}%inline%\textit{]}% %\textit{fct-name} \textit{parameter-list [}%:%\textit{return-type ]}% = %\textit{fct-body}%

%Examples: %
  let sum x y = x + y
  (* Whitespaces matter; nesting by indentation. *) 
  let inc x =
    let step = 1
    sum x step
  (* Functions are values *)
  let binOp (f: int -> int -> int) x y = f x y
  let plus x y = binOp (+) x y
\end{lstlisting}
Function
\begin{itemize}
\item<+-> types (if possible) automatically inferred and generalized.
\item<+-> body is a sequence of expressions.
\item<+-> body evaluates to value of last expression.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{More on Functions}
\begin{lstlisting}[language=FSharp, escapechar=\%]
(* Lambda expressions *)
let dup y = (fun x -> x * 2) y
let mul x y = binOp (fun x y -> x * y) x y

(* Function can be declared with tuple parameter *)
let mul2 (x, y) = x * y 
  
let dup2 = mul2 2  (* error *)

mul2 (4,5) (* instead of *) mul2 4 5
\end{lstlisting}  
\begin{itemize}
  \item Lambda expressions (anonymous functions) supported
  \item Tuple parameters for functions $\Rightarrow$ no partial function application
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Recursive Functions}

\Blue{Recursive functions must be explicitly declared using \alert{rec}}

\begin{center}
\begin{lstlisting}[language=FSharp, escapechar=\%]
let %\color{red}\textsf{rec}\color{black}% fct-name = expr
\end{lstlisting}  
\end{center}

Example:

\begin{lstlisting}[language=FSharp, escapechar=\%]
let rec fib n =
   if n <= 2 then 1
   else fib (n - 1) + fib (n - 2)
\end{lstlisting}  

\end{frame}

\begin{frame}[fragile]{F\#: Pure or Impure?}

Consider:
\begin{lstlisting}[language=FSharp]
let rec fib n = 
    printf "Called with %d\n" n
    if n <= 2 then 1 
    else fib (n - 1) + fib (n - 2)
\end{lstlisting}  
\pause
Output:
\begin{lstlisting}[language=FSharp]
> pp.fib 3;;
 Called with 3 
 Called with 2 
 Called with 1 
 val it : int = 2
\end{lstlisting}
\bigskip

\begin{center}
  Expressions can have \emph{side-effects} $\Rightarrow$ F\# is \emph{impure}.
\end{center}
\end{frame}


\begin{frame}[fragile]{Discriminate Unions}

General Declration:

\begin{lstlisting}[language=FSharp, escapechar=\%]
type %\it type-name% = 
   | %\it case-identifier1 %[ of %\it type1% [ * %\it type2 ...%]]
   | %\it case-identifier2 %[ of %\it type3% [ * %\it type4 ...%]]
  ...
\end{lstlisting}

Example:

\begin{lstlisting}[language=FSharp, escapechar=\%]
type Color = 
    | Red 
    | Black
type Tree  =
    | Leaf 
    | Node of Color * Tree * Tree
%\pause%
let tree0 = Leaf
let tree1 = Node(Black, Leaf, Leaf)
let tree2 = Node(Black, Node(Red, Leaf, Leaf), Node(Red, Leaf, Leaf))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Pattern Matching}
\begin{lstlisting}[language=FSharp, escapechar=\%]
match %\it test-expression% with
    | %\it pattern1% [ when %\it condition% ] -> %\it result-expression1%
    | %\it pattern2% [ when %\it condition% ] -> %\it result-expression2%
    | ...
\end{lstlisting}

\pause

Example:
\begin{lstlisting}[language=FSharp, escapechar=\%]
let rec countRed tree =
    match tree with
    | Leaf -> 0
    | Node(Red, left, right) ->
         1 + countRed(left) + countRed(right)
    | Node(Black, left, right) ->
         0 + countRed(left) + countRed(right)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Lists and Listgenerators}
\begin{overlayarea}{\textwidth}{0.35\textheight}
\begin{lstlisting}[language=FSharp, escapechar=\%]
let list = [ %\it el1%; %\it el2%; %\it el3% ]   
%\pause%
let list = [ for i in %\it coll% do %\it exp-with-yield% ]   
let list = [ for i in %\it coll% <- %\it exp% ]   
%\pause\color{red}\\[-1em]\smallskip General view:%
     [ %\it computation-workflow-exp % ]   
\end{lstlisting}
\end{overlayarea}
\onslide<1->
List construction:
\begin{itemize}
\item<1-> explicit element enumeration
\item<2-> looping constructs
  \begin{itemize}
    \item imperative flavor
    \item $coll$ any \textsl{.net}-class implementing \texttt{IEnumerable<T>} 
    \item \textit{exp-with-yield}: expression sequence with sub-exp.\ '\lstinline!yield! $elExp$' where $elExp$ evaluates to the value to be added
    \item shortform \lstinline!<-! if $exp$ evaluates to the value to be added 
 \end{itemize}
\item<3-> List constructor \lstinline![]! gets a
  \emph{computation-workflow expression} (provide syntax for monads)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Listgenerators: Examples}
\begin{lstlisting}[language=FSharp]
 (* list generation by explicit enumeration *)
let list1 = [ 1; 2; 3 ] 

(* list generation from .. step .. to .. *)
let listOdd1to100 = [1 .. 2 .. 100]

(* list generation using looping construct *)
let listEven1To100 = [for i in 1..49 -> i * 2 ]  
let altListEven1To100 = [for i in 1..49 do if i%2=0 then yield i * 2 ]  

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Operation on Lists}
\begin{lstlisting}
(* add element as head *)
let list2 = 0 :: list1
(* concatenate lists *)
let list3 = list1 @ list2
(* recursion and matching on lists *)
let rec sum list =
   match list with
   | head :: tail -> head + sum tail
   | [] -> 0
(* provided by package List *)
List.sort [1; 2; 3]
List.sum [1; 2; 3]
\end{lstlisting}

\pause

Lists are constructed eagerly. For lazy/on-demand use \emph{sequences}.

\begin{lstlisting}[language=FSharp]
  let first1000  = seq { for i in 1..1000 -> i }
  let natNumbers = Seq.unfold (fun i -> Some(i, i + 1)) 0
  for i in 80..90 do printf "%d;" (Seq.nth i natNumbers)
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Pipelining}

\Blue{Task:} Select all even numbers from a list and sort the result:

\pause

\begin{lstlisting}[language=FSharp]
  List.sort List.filter (fun x -> x%2 = 0) [4; 2; 1; 3; 9; 11; 8]
\end{lstlisting}

\pause\bigskip

Improve readability using \emph{pipelining} \lstinline!|>! instead 

\begin{lstlisting}[language=FSharp]
  [4; 2; 1; 3; 9; 11; 8] 
    |> List.filter (fun x -> x%2 = 0) 
    |> List.sort ;;
\end{lstlisting}

\pause\bigskip

The pipeline operator is basically defined as

\begin{lstlisting}[language=FSharp]
  let (|>) x f = f x 
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Mutability in F\#: Mutable Variables}

\Blue{Mutable variables}

Declaration:

\begin{lstlisting}[language=FSharp, escapechar=\%]
             let %\alert{mutable}\it\ var-name% = %\it exp% 
\end{lstlisting}

\begin{itemize}
\item Should only be used local (better control!)
\item Mutability causes same complications as in imperative languages
  \begin{itemize}
    \item side-effects, e.g., evaluation order of expressions important
    \item aliasing (see later)
   \end{itemize}
\end{itemize}

\pause 

Update (assignment):
\begin{lstlisting}[language=FSharp, escapechar=\%]
  %\it var-name% <- %\it new-value%
\end{lstlisting}

\pause 

\begin{center}
\alert{Attention: F\# is strongly typed!}
\end{center}

\end{frame}


\begin{frame}[fragile]{Mutability in F\#: Reference Cells}

\Blue{Reference Cells}

Creation:
\begin{lstlisting}[language=FSharp, escapechar=\%]
             let %\it\ ref-var-name% = %\it\alert{ref}\ exp% 
\end{lstlisting}

\begin{itemize}
  \item creates a reference cell with a \emph{mutable} value, here: $exp$
\end{itemize}

\pause 

Update (Assignment) and Content Access:
\begin{lstlisting}[language=FSharp, escapechar=\%]
(* updating reference cell content *)
    %\it ref-var-name% %\alert{:=}% %\it new-value%

(* accessing reference cell content *)
    %\alert{!}\it ref-var-name% 
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Mutable Variables vs. Reference Cell}

\begin{lstlisting}[language=FSharp, escapechar=\%]
  let mul x y = x * y
  let mutable factor = 2
  let dup = mul factor

  let mulRef x y = !x * y
  let factorRef = ref 2
  let dupRef = mulRef factorRef

  dup 5 (* value%\color{green!50!black!80}\only<1>{?}\only<2->{ = 10}% *)
  dupRef 5 (* value%\color{green!50!black!80}\only<1>{?}\only<2->{ = 10}% *)
%\onslide<3->% 
  factor <- 3; factorRef := 3
  dup 5     (* value%\color{green!50!black!80}\only<3>{?}\only<4->{ = 10}% *)
  dupRef 5  (* value%\color{green!50!black!80}\only<3>{?}\only<4->{ = 15}% *)
\end{lstlisting}


\begin{itemize}
\item<4-> Closures: Arguments passed as values not by reference
\item<4-> Reference cell need if change of value shall effect closure
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Parameter Passing: By-Reference}

\begin{lstlisting}[language=FSharp, escapechar=\%]
  let mul (x:int byref) y = x * y
  let mutable factor = 2
  let dup    = mul &factor

  dup 5 (* value%\color{green!50!black!80}\only<1>{?}\only<2->{ = 10}% *)
%\onslide<2->% 
  factor <- 3; factorRef := 3
  dup 5     (* value%\color{green!50!black!80}\only<3>{?}\only<4->{ = 15}% *)
\end{lstlisting}

Observations:
\begin{itemize}
\item F\# supports parameter passing by reference
\item Mutable variable needs to be prefixed with \lstinline{&}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{While loops in F\#}
  F\# knows actual \lstinline!while! loops:

\begin{lstlisting}[language=FSharp, escapechar=\']
    let mutable counter = 10 

    while counter>0 do
      printf "%d" counter
      count <- counter - 1

'equivalent'

    let counter = ref 10 

    while !counter>0 do
      printf "%d" !counter
      counter := !counter - 1
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Classes and Objects in F\#}
\begin{lstlisting}[language=FSharp, basicstyle=\small, escapechar=\%]
type CRectangle(upperLeft:Point2D, lowerRight:Point2D, col:Color) =
class (* optional *)
    static let mutable counter = 0

    let ul = upperLeft
    let ur = lowerRight
    let mutable color = col

    do counter <- counter + 1
    ...
end (* optional *)
\end{lstlisting}%
Remarks:
\onslide<1->
\begin{overlayarea}{\textwidth}{0.3\textheight}
\begin{itemize}
  \item<+-> private fields/methods are declared as \lstinline{let}
    bindings; static fields/methods use the \lstinline!static! keyword
  \item<+-> \lstinline!do! bindings are initialisers
  \item<+-> \lstinline!let! bindings and \lstinline!do! bindings form the
    primary constructor whose arguments are given in parentheses
\end{itemize}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Additional Constructors}
\begin{lstlisting}[language=FSharp, escapechar=\%]
type CRectangle(upperLeft:Point2D, lowerRight:Point2D, col:Color) =
    static let mutable counter = 0

    let ul = upperLeft
    let ur = lowerRight
    let mutable color = col

    do
        counter <- counter + 1

    new(ul, lr) = CRectangle(ul, lr, RGB(0,0,0))     
\end{lstlisting}

\begin{overlayarea}{\textwidth}{0.3\textheight}
\begin{itemize}
 \item<+-> possible to define additional constructors but primary
   constructor must be invoked
\end{itemize}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Public Members}
\begin{lstlisting}[language=FSharp, escapechar=\%]
   type CRectangle(upperLeft:Point2D, lowerRight:Point2D, col:Color) =
   ...

   member Area =
       (lowerRight.x - upperLeft.x) * (lowerRight.y - upperLeft.y)

   member %\alert<2>{self}%.Color(col:Color) = color <- col
\end{lstlisting}

\begin{overlayarea}{\textwidth}{0.3\textheight}
\begin{itemize}
 \item<+-> public members are declared using \lstinline!member!
 \item<+-> qualification of \lstinline!member! needed if access to
   private fields/methods needs to be possible
   \begin{itemize}
     \item free to choose any qualifier (often used: \lstinline!self, this!)
     \item attention: member Area needs no access to private fields
       (uses constructor parameters directly)
  \end{itemize}
\end{itemize}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Class Inheritance}
\begin{lstlisting}[language=FSharp, escapechar=\%]
type AShape(col:Color) =
    let mutable color = col
    member self.Color(c) = col <- c 
    abstract member self.Area: -> float

type CRectangle(upperLeft:Point2D, lowerRight:Point2D, col:Color) 
inherit AShape(col) =  ...
   override self.Area() = (lowerRight.x - upperLeft.x) * (...)
\end{lstlisting}

\Blue{Remarks:}
\begin{overlayarea}{\textwidth}{0.6\textheight}
\begin{itemize}
 \item<+-> single class inheritance
 \item<+-> primary constructor of superclass must be invoked (in
   parentheses following the \lstinline!inherit! expression.
 \item<+-> overriding requires use of \lstinline!override! keyword 
 \item<+-> possible (not done here) to provide a default
   implementation for an abstract method
\end{itemize}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Interfaces}
\begin{lstlisting}
type IColored =
interface
  abstract member Color: Color -> unit
  abstract member Color: Color
end 

type IShape =
 abstract member self.Area: float

type IColoredShape =
 inherit IColored
 inherit IShape
 abstract member fill: bool -> unit
\end{lstlisting}

\begin{overlayarea}{\textwidth}{0.3\textheight}
\begin{itemize}
\item<+-> all members must be declared \lstinline!abstract! (default
  impl.\ possible)
\item<+-> keywords \lstinline!interface, end! optional (if missing,
  compiler tries to infer if it is a class or interface)
\item<+-> interface can inherit from multiple other interfaces
\end{itemize}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Class implementing Interfaces}
\begin{lstlisting}[basicstyle=\scriptsize]
type IColored = interface
  abstract member Color: Color -> unit
  abstract member Color: Color
end 

type IShape =
 abstract member Area: float

type CRectangle(upperLeft:Point2D, lowerRight:Point2D, col:Color) 
 let mutable color = col
 interface IColored with
   member self.Color(col) = color <- col
   member self.Color = color
 interface IShape with
   member self.Area = (lowerRight.x - upperLeft.x) * (...)
 ...
\end{lstlisting}

Remarks:
\begin{overlayarea}{\textwidth}{0.3\textheight}
\begin{itemize}
\item<+-> class implements interfaces via keywords 
  \lstinline!interface ... with!
\end{itemize}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Class implementing Interfaces}
\begin{lstlisting}[basicstyle=\scriptsize]
type CRectangle(upperLeft:Point2D, lowerRight:Point2D, col:Color) 
 let mutable color = col
 interface IColored with
   member self.Color(col) = color <- col
   member self.Color = color
 interface IShape with
   member self.Area = (lowerRight.x - upperLeft.x) * (...)
 ...

let rect = new CRectangle(...)
rect.Area  (* not possible, call must go vi interface type)

(rect :> IShape).Area
\end{lstlisting}

Remarks:
\begin{overlayarea}{\textwidth}{0.3\textheight}
\begin{itemize}
\item<+-> interface method cannot be invoked on class (upcast needed)
\item<+-> allows to provide different impl.\ for method of same name
  inherited from different interfaces
\end{itemize}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Usage of Classes}

\Blue{Interoperability}

Use classes if 
\begin{itemize}
\item you want to provide APIs to others using \textsf{.net}
but not necessarily F\#
\item at places where you have to interact with the \textsf{.net}
  environment.
\item otherwise try to use discriminated unions, records or structs
  together with pattern matching on these expressions
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Asynchronous Workflows}
\Blue{F\# provides an easy way to execute tasks in parallel}

\begin{lstlisting}[escapechar=\%]
let rec fib x =
   match x with
    | 0 -> 1
    | 1 -> 2
    | n -> fib(x - 1) + fib(x - 2)

let task1 n  = async { return fib(n) }
let task2 n  = async { return fib(n) }

let fibTwoTasksInParallel = Async.Parallel[task1; task2] 
Async.RunSynchronously fibTwoTasksInParallel

(* or (scales) *)

let fibs =
    Async.Parallel [ for i in 0 .. 40 -> async { return fib(i) } ]
    |> Async.RunSynchronously
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Asynchronous Workflows}

The expression
\color{blue}
\begin{lstlisting}
  async { workflow-exp }
\end{lstlisting}
\color{black}

creates an asynchronous workflow. 

\medskip

\emph{Workflow expressions} define the computation logic, e.g.,
compute 
\begin{itemize}
\item fibonacci number,
\item average file length of given files or
\item sum of all characters in given files. 
\end{itemize}

\medskip

The function \lstinline!Async.Parallel! groups all tasks which are
then run in parallel by applying \lstinline!Async.RunSynchronously!.

\medskip

The return value is extracted from the asynchronous workflow with help
of the \lstinline!return! function.

\end{frame}





\appendix

\begin{frame}[fragile]{General Class Declaration}

\begin{lstlisting}[language=FSharp, escapechar=\%]
type [%$access-modifier$%] %$type\!-\!name$% 
         [%$type-params$%](%$parameter\!-\!list$%) %$[$%as %$identifier]$% =
   %$[$% class %$]$%
     %$[$% inherit %$base-type-name$%(%$base\!-\!constructor\!-\!args$%) %]%
     %$[let-bindings]$%
     %$[do-bindings]$%
     %$member-list$%
   %$[$% end %$]$%
\end{lstlisting}

\begin{itemize}
  \item private fields/methods are declared as \lstinline{let} bindings
  \item \lstinline!do! bindings are initialisers
  \item upon construction let and do bindings are executed in source code order
\end{itemize}
\end{frame}


\end{document}