\documentclass{article}

\usepackage[latin9]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{pdfpages}
\usepackage{todonotes}
\usepackage{t1enc}         
\usepackage[english]{babel}
\usepackage{times}
\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{textcomp}

\newcommand{\percents}[1]{\protect \marginpar[l]{\bf [#1]}}
\newcounter{question}
\newcommand{\question}[2]{
  \addtocounter{question}{1}
  \paragraph{Exercise~\arabic{question}  \percents{#1}}
   #2
  \vfil
 }



\begin{document}
%\listoftodos

\title{Exercises on Imperative Programming\\
  \large Programming Paradigms}
\author{Ramona Enache}
\maketitle

%\newcommand{\answer}[1]{} %{\begin{quote}{\bf Answer:} #1\end{quote}}
\newcommand{\percent}[1]{} %{\marginpar{\bf #1 }}
\section{Gotos to loops}

Consider the algorithm:

\begin{enumerate}
\item \textbf {Preliminary:} {\it A} is an array of integers of length
  {\it n} and {\it B} is an array of integers of length {\it m}. Also
  the elements from both arrays are distinct (from the elements in
  both arrays) and in ascending order. 

\item \textbf{Step1:} if {\it n} or {\it m} is zero
  \textbf{STOP}. Otherwise if  $m\textgreater n$, set $t := \lfloor log
    \left ( m \slash n \right ) \rfloor $  and go to \textbf{Step4},
    else set $t := \lfloor log
    \left ( n \slash m \right ) \rfloor $.

\item \textbf{Step2:} compare {\it A[m]} with {\it B[n + 1 -
    $2^t$]}. If {\it A[m]} is smaller, set {\it n := n - $2^t$} and
  return to \textbf{Step1}.

\item \textbf{Step3:} using binary search(which requires exactly {\it
    t} more comparisons), insert {\it A[m]} into its proper place
  among {\it B[n + 1 -$2^t$] ... B[n]}. If {\it k} is maximal such
  that {\it B[k] \textless A[m]}, set {\it m := m - 1} and {\it n :=
    k}. Return to \textbf{Step1}.

\item \textbf{Step4:}(Step 4 and 5 are like 2 and 4, interchanging the
  roles of {\it n} and {\it m}, {\it A} and {\it B}) if {\it B[n]
    \textless A[m+1-$2^t$]}, set {\it m := m - $2^t$} and return to
  \textbf{Step1}.

\item \textbf{Step5:} insert {\it B[n]} into its proper place among
  the {\it A}s. If {\it k} is maximal such that {\it A[k] \textless
    B[n]}, set {\it m := k} and {\it n := n - 1}. Return to \textbf{Step1}.


\end{enumerate}


\question{*} 

implement binary search without gotos in the context of the
algorithm. There is a slight change compared to the classical
algorithm, since the scope of the search is different. Keep in mind! 
\todo[noline]{or} 

\question{*} 

\textbf{Step1} may require the calculation of the expression $\lfloor log
    \left ( m \slash n \right ) \rfloor $, for $n \geq m$. Explain how
    to compute this easily without division or calculation of a
    logarithm.  \todo[inline]{with gotos or explicit stack}

\question{*} 

Why does the binary search mentioned in the algorithm
always take {\it t} steps ?

\question{*} 

Explain the behaviour of the algorithm for the arrays 
{\it A} = \{87, 503, 512\} and {\it B} = \{61, 154, 170, 275, 426, 509,
  612, 653, 677, 703, 765, 897, 908\}.

\question{**} 

Implement the above-mentioned algorithm without using
{\it gotos} in a programming language of your choice. Check your
implementation with the {\it A} and {\it B} from the previous question. 

  
\section{Loops to gotos}
\question{*}

Translate the following \textbf{for} loop with explicit gotos:
\\
\\
{\it for (statement; condition; statement)

$\ \ \ \ $loop$\_$body}


\section{Pointers}
\question{*}

Create a binary search tree where nodes contain integer number in
C/C++. Implement a function that adds a value to the tree and one that
deletes a certain value from the tree. 
\todo[inline]{maybe smth more interesting, red-black/Fibonacci tree...}


\question{*}

Smth here ...
\todo[noline]{pointers in Java}

\section{Explicit stacks}
Consider the following recursive relation for computing Fibonacci
numbers:
\\
\\
{\it $fib_{n+2} = fib_{n+1} + fib_{n}$}

\question{*}

Implement the recursive function computing the n-th Fibonacci number based on
the expression above. Why is it not efficient ?

\question{*}

Implement a slightly-optimized recursive function for the same
purpose.

\question{**}

Implement a version of one of the two functions above by using an
explicit stack.  

\end{document}