\documentclass{article}

\usepackage[utf8x]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{todonotes}
\usepackage[english]{babel}
%\usepackage{times}
\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{verbatim}
\usepackage{hyperref}

\newcommand{\percents}[1]{\protect \marginpar[l]{\bf [#1]}}
\newcounter{question}
\newcommand{\question}[1]{
  \addtocounter{question}{1}
  % {\bf Exercise~\arabic{question}} \percents{#1}
  \paragraph{Exercise~\arabic{question}  \percents{#1}}
 }
\newenvironment{ex}[1]{\question{#1}}{\vspace{1em}}
\newcommand{\removed}[1]{}

\newcommand{\answer}[1]{}

% Uncomment to show answers
% \renewcommand{\answer}[1]{#1}


\usepackage{listings}

\lstset{language=java,basicstyle=\small}
\lstset{commentstyle=\textit,flexiblecolumns=true,mathescape=true}
\lstnewenvironment{java}
    {\lstset{language=java,frame=tb}}
    {}
\lstnewenvironment{java2}
    {\lstset{language=java}}
    {}
\lstnewenvironment{cplus}
    {\lstset{language=c++,frame=tb}}
    {}
\lstnewenvironment{cplus2}
    {\lstset{language=c++}}
    {}
\lstnewenvironment{perl}
    {\lstset{language=perl,mathescape=false,lineskip=0\baselineskip}}
    {}


\lstdefinelanguage{FSharp}
      {morekeywords={let, new, match, with, rec, open, module,
           namespace, type, of, member, and, for, in, do,
           begin, end, fun, function, try, mutable, if, then, else, class, end},
    keywordstyle=\color{blue},
    sensitive=false,
    morecomment=[l][\color{green!50!black!80}]{///},
    morecomment=[l][\color{green!50!black!80}]{//},
    morecomment=[s][\color{green!50!black!80}]{{(*}{*)}},
    morestring=[b]",
    stringstyle=\color{red},
    columns=fullflexible
}

\lstnewenvironment{prolog}
    {\lstset{language=prolog,frame=tb}}
    {}

\begin{document}
%\listoftodos

\title{Programming Paradigms: Exercises}
% \author{Ramona Enache, Jean-Philippe Bernardy\footnote{with thanks to previous teams in charge of the course.}}
\maketitle


\section{Generalities}

\subsection{Paradigms, Languages, Features}
Consider the language C++ (or your favourite programming language,
...).

\question{*} Write a list of features (programming constructs)
implemented in C++. Be as exhaustive as you can (list at least 10
features).

\question{*} For each programming paradigm (Imperative, OO, etc.),
evaluate how well C++ supports that paradigm. Argue using the list
compiled in the previous answer.

\question{***} Can you identify a paradigm not studied in the course
which is supported by C++?

\subsection{Types}

\question{*} Give a meaningful type to the following values.

\begin{enumerate}
\item 4
\item 123.53
\item 1/3
\item $\pi$
\item 'c'
\item ``Hello, world!''
\item -3
\item (unary) -
\item (binary) +
\item sin
\item derivative
\end{enumerate}

\question{**} Explain the meaning of the following types. (Hint: what
kind of values can inhabit those types?)

\begin{enumerate}
\item String
\item String → String
\item String → String → String
\item (String → String) → String
\item String → (String → String)
\item (String → String) → (String → String)
\end{enumerate}
% FIXME: the above already has an implicit notion of currification, so
% the exercise should be split/simplified.


One can not only parameterize over values, but also over
types. (Eg. in Java, generic classes).

For example, the following type is a suitable type for a sorting
function: it expresses that the function works for any element type,
as long as you can compare its inhabitants.

∀ a. (a → a → Bool) → Array a → Array a


\question{**} Does sort in your favourite language have a similar
type? How close/far is it?

Consider the type
\[∀ a\,b. \mathsf{Pair}\,a\,b → \mathsf{Pair}\,b\,a\]
\question{***} What can possibly inhabit it?


\newpage % so the algorithm below is not broken
\section{Imperative Programming}

\subsection{Gotos to loops}

Consider the algorithm:

\begin{enumerate}
\item \textbf {Preliminary:} {\it A} is an array of integers of length
  {\it m} and {\it B} is an array of integers of length {\it n}. Also
  the elements from both arrays are distinct (from the elements in
  both arrays) and in ascending order.

\item \textbf{Step1:} if {\it n} or {\it m} is zero
  \textbf{STOP}. Otherwise if  $m\textgreater n$, set $t := \lfloor log
    \left ( m \slash n \right ) \rfloor $  and go to \textbf{Step4},
    else set $t := \lfloor log
    \left ( n \slash m \right ) \rfloor $.

\item \textbf{Step2:} compare {\it A[m]} with {\it B[n + 1 -
    $2^t$]}. If {\it A[m]} is smaller, set {\it n := n - $2^t$} and
  return to \textbf{Step1}.

\item \textbf{Step3:} using binary search(which requires exactly {\it
    t} more comparisons), insert {\it A[m]} into its proper place
  among {\it B[n + 1 -$2^t$] ... B[n]}. If {\it k} is maximal such
  that {\it B[k] \textless A[m]}, set {\it m := m - 1} and {\it n :=
    k}. Return to \textbf{Step1}.

\item \textbf{Step4:}(Step 4 and 5 are like 2 and 4, interchanging the
  roles of {\it n} and {\it m}, {\it A} and {\it B}) if {\it B[n]
    \textless A[m+1-$2^t$]}, set {\it m := m - $2^t$} and return to
  \textbf{Step1}.

\item \textbf{Step5:} insert {\it B[n]} into its proper place among
  the {\it A}s. If {\it k} is maximal such that {\it A[k] \textless
    B[n]}, set {\it m := k} and {\it n := n - 1}. Return to \textbf{Step1}.


\end{enumerate}


\question{*}

implement binary search without gotos in the context of the
algorithm. There is a slight change compared to the classical
algorithm, since the scope of the search is different. Keep in mind!
\footnote{If that is too easy, do it for red-black trees.}


\question{-}

\textbf{Step1} may require the calculation of the expression $\lfloor log
    \left ( m \slash n \right ) \rfloor $, for $n \geq m$. Explain how
    to compute this easily without division or calculation of a
    logarithm.  % \todo[inline]{with gotos or explicit stack}

\question{*}

Why does the binary search mentioned in the algorithm
always take {\it t} steps ?

\question{*}

Explain the behaviour of the algorithm for the arrays
{\it A} = \{87, 503, 512\} and {\it B} = \{61, 154, 170, 275, 426, 509,
  612, 653, 677, 703, 765, 897, 908\}.

\question{**}

Implement the above-mentioned algorithm without using
{\it gotos} in a programming language of your choice. Check your
implementation with the {\it A} and {\it B} from the previous question.


\subsection{Control flow statements to gotos}
\question{*}

Translate the following \textbf{for} loop with explicit gotos:
\\
\\
{\it for (statement1; condition; statement2)

$\ \ \ \ $loop$\_$body}
\question{*}

Translate the following \textbf{foreach} loop with explicit gotos:
\begin{verbatim}
  foreach i in k..l do
    body
\end{verbatim}

\question{*}
Translate the do/while construct.

\question{*}
Translate the switch/case construct.

(If you want to make sure your translation is correct you should check the
specification of the C language. \url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf})

\question{*}
Translate the insertion sort algorithm.



\subsection{Pointers and call by reference}

\question{*}
Create a binary search tree where nodes contain integer number in
C/C++/Java. Implement a function that adds a value to the tree and one that
deletes a certain value from the tree.

\question{*}
Write a recursive traversal of the above tree.

\question{*}
Write a swap function using call by reference.

\question{*}
Write a swap function using call by value.

\question{**} Does Java use call by reference? Give examples to support
your answer.

\question{**} Write down pros and cons of using call by reference
vs. call by value. (Ease of use, performance, ...)

\subsection{More on control flow and pointers: Duff's device}
Duff's device is an optimization idiom for serial copies
in the language C. The fragment below lists first the original code,
then Duff's optimization.
\pagebreak
\begin{cplus}
/* (Almost) original code */
int main() {
   short *to, *from;
   int count;
   ...
   {
     /* pre: count > 0 */
     do
	  *to++ = *from++;
     while(--count>0);
   }
   return 0;
}
\end{cplus}

Many things happen in the assignment ``\textsf{*to++ = *from++;}''. Can you figure out what exactly?
\begin{ex}{*}
  Translate the above to multiple statements, so that for each of them
  only one variable (or memory location) is updated.  Explain in your
  own words what happens (draw a picture if necessary).  \answer{ It
    is equivalent to \texttt{*to = *from; to++; from++;}.  In other
    words, the memory pointed by \texttt{from} is copied to the memory
    pointed by \texttt{to}, then the pointers are incremented.  }
\end{ex}


Duff optimised the above code as follows:
\begin{cplus}
/* Duff's transformation */
int main() {
  short *to, *from;
  int count;
  ...
  {
     /* pre: count > 0 */
     int n = (count + 7) / 8;
     switch(count % 8){
       case 0:	do{	*to++ = *from++;
       case 7:	        *to++ = *from++;
       case 6:	        *to++ = *from++;
       case 5:	        *to++ = *from++;
       case 4:	        *to++ = *from++;
       case 3:	        *to++ = *from++;
       case 2:	        *to++ = *from++;
       case 1:	        *to++ = *from++;
                } while (--n > 0);
     }
  }
  return 0;
}
\end{cplus}

\begin{ex}{**}
  Translate the switch statements to gotos.
\end{ex}

Is the second program really equivalent to the first?

\begin{ex}{-}
Show that the instruction ``\texttt{*to++ = *from++}'' will be executed
\texttt{count} times in the second program.
\answer{The while loop will be executed $\floor{(count + 7) / 8}$ times.
Since each iteration executes the instruction 8 times, we expect the
program to run it $8 \times \floor{(count + 7)/ 8}$ times in total, which
is up to 7 times more than count.

However, the \texttt{switch} instruction is there to skip
$count \bmod 8$ instructions in \emph{the first iteration}, to
make the count exact.
 }
\end{ex}

\begin{ex}{****}
  Explain the equivalence by a series of program transformations.
\end{ex}

\providecommand{\floor}[1]{\lfloor #1 \rfloor}
\begin{ex}{-}
  Can you guess why Duff expects the second program to be faster?
  What instructions are executed in the first program but not in the
  second?

  \answer{The test and jump instructions are executed only
    $\floor{(count + 7) / 8}$ times instead of $count$, which is about
    $1/8$ of the time.}
\end{ex}


\paragraph{Further reading}
\begin{itemize}
\item For the original email in which Tom Duff presented his ``device'',
see

\url{http://www.lysator.liu.se/c/duffs-device.html}

\item You can see the assembly code generated by \textsf{gcc} by
  compiling with
  \begin{center}
    \textsf{gcc -S $<$filename$>$}.
  \end{center}
\end{itemize}


\subsection{From recursion to explicit stack}
\begin{ex}{**}
Re-implement the tree traversal (from above), but using explicit stacks.
\end{ex}


Consider the following recursive equation for computing Fibonacci
numbers:
\providecommand{\fib}{\mathnormal{fib}}
\[
\fib_{n+2} = \fib_{n+1} + \fib_{n}
\]

\question{*}
Implement the recursive function computing the n-th Fibonacci number based on
the expression above.

\question{*} Why is it not efficient?

\question{*}

Implement a slightly-optimized recursive function for the same
purpose. (Hint: use an accumulator parameter).

\question{**}
Implement a version of each of the two functions above by using an
explicit stack.

\question{**}
Implement the Ackermann function without recursion.
(See \url{http://en.wikipedia.org/wiki/Ackermann_function}).

\question{**} Implement the algorithm from the previous section
without loops (only recursion allowed).

\question{**}
Translate the quicksort algorithm.

\question{**} 
Implement the following algorithm as a recursive
function. (And remove the loop!)
\begin{verbatim}
a = 0
b = 1
for i in [1..n] do
  c = a + b
  a = b
  b = c
return a  
\end{verbatim}

\section{Object-Oriented Programming}

Consider the following code, in C\# syntax:
\begin{java}
interface Monoid {
   Monoid op(Monoid second);
   Monoid id();
};

struct IntegerAdditiveMonoid : Monoid {
    public IntegerAdditiveMonoid(int x) {
         elt = x;
    }
    public IntegerAdditiveMonoid op(IntegerAdditiveMonoid second) {
         return new IntegerAdditiveMonoid(
             elt + second.elt);
    }
    public IntegerAdditiveMonoid id(){
         return new IntegerAdditiveMonoid(0);
    }
    int elt;
};

\end{java}
%

\subsection{Explicit method pointers}

\question{*} Translate the above code to a C-like language, using
explicit method pointers. (Hint: you can simply consider the interface
as a class without fields.)

\question{-} Briefly recap: what is a \textit{monoid}, mathematically?

\question{-} Give two examples of data types that can be considered monoids.
(Hint: Strings would form a monoid under the appropriate structure; what is the structure?

\question{*} Write another instance of the monoid interface, using one
of the examples you found. Also write its translation to a C-like
language.

\question{*} Assume variables \textsf{a,b} of type \textsf{Monoid}. Translate
the expression \textsf{a.op(b)}.

\question{*} Assume to objects \textsf{x,y} of two different instances
of Monoid are bound to the variables \textsf{a,b}. Explain what
happens at runtime when the expression is evaluated. (Which code is executed?)

\subsection{Co/Contra variance}

Surprise: the above code is refused by the C\# compiler:
\begin{verbatim}
> gmcs Monoids.cs
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement
  interface member `Monoid.op(Monoid)'
Monoids.cs(2,11): (Location of the symbol related to previous error)
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement
  interface member `Monoid.id()'
Monoids.cs(3,11): (Location of the symbol related to previous error)
Compilation failed: 2 error(s), 0 warnings
\end{verbatim}


\question{*} What if the method \textsf{op} \textit{would} compile?
Define objects \textsf{a,b}, of appropriate types, so that
\textsf{a.op(b)}, if is run, would result in a run-time error.

\question{*} What if the method \textsf{id} would compile? Could you
construct a similar run-time error? (Hint: do the translation job if
the answer is not obvious to you.)

\question{**} Explain the error messages in terms of co-/contra-/nonvariance.

\question{***} The corresponding program in Java behaves differently. Briefly
explain how, consult the Java Language Specification (JLS), and back your answer
with the appropriate clause(s) in the JLS.

\question{-} Can you change the code so that the (current)
C\#-compiler accepts it? What is the problem then?

\removed{
\subsection{Dynamic dispatching \& the visitor}

Suppose the three classes \textsf{Shape}, \textsf{Rectangle}, and
\textsf{Circle}, and the appropriate inheritance relation between them.
Further assume a method \textsf{intersect()} that can determine whether two
shapes overlap. Obviously, the implementation of \textsf{intersect()}
depends on the actual shapes involved.

\question{*} Implement and design the 3 classes so that all possible
intersections of shapes can be properly handled using Smalltalk.  What
is the problem with single dispatching? Name at least 2 issues.


  The following Java snippet redesigns the
  class hierarchy using \textit{double dispatch}.
  Explain how double dispatching works by
  giving the sequence of calls for the line marked (*) in \textsf{Main}.
  Name two problems with double dispatching.

\begin{java}
class Shape {
    public  boolean intersect(Shape s) {
         return s.intersectShape(this);
    }
    protected  boolean intersectShape(Shape s) {
        // intersect Shape x Shape
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // no special code for Shape x Rectangle
        return intersectShape(r);
    }
    protected  boolean intersectCircle(Circle c) {
        return intersectShape(c);
   }
}
class Rectangle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectRectangle(this);
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // Rectangle x Rectangle
        ..
    }
}
class Circle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectCircle(this);
    }
    protected  boolean intersectCircle(Circle c) {
        // Circle x Circle
   }
}

class Intersect {
   public static void Main() {
      Shape s1 = new Rectangle();
      Shape s2 = new Circle();
      boolean b = s2.intersect(s1);        // *
   }
}
\end{java}

The \textit{Visitor pattern} provides an alternative workaround,
also based on double dispatching. In difference
to the solution above, the pattern
introduces two hierarchies, the visited
hierarchy and the visitor hierarchy. In the example,
 \textsf{Shape, Rectangle, Circle}
form the visited hierarchy, \textsf{IntersectVisitor} and its two
subclasses \textsf{RectangleIntersectVisitor} and \textsf{CircleIntersectVisitor}
form the visiting hierarchy. The visited classes are
augmented with a method \textsf{accept}, which uses double dispatching
to call the appropriate ShapeVisitor (and to invoke the
right computation).

\question{*} Complete the code for the two class hierarchies and the client.
\question{*} Name two problems of the visitor approach.

\begin{java2}
class Shape {
    public void accept(IntersectVisitor v) {
	v.visitShape(this);
    }
}
class Rectangle extends Shape {
public  void accept(IntersectVisitor v) {
        // your job
    }
}
class Circle extends Shape {
   // your job
}

// visitor hierarchy
abstract class IntersectVisitor {
    boolean intersects;
    public abstract void visitShape(Shape s);
    public abstract void visitRectangle(Rectangle r);
    public abstract void visitCircle(Circle c);
}

// client code
  Shape s1 = new ..
  IntersectVisitor v = new RectangleIntersectVisitor();
  s1.accept(v);
  if (v.intersects) ...
\end{java2}
}

\section{Functional Programming}
\subsection{Algebraic Data Types and Pattern Matching}

\question{*} Define an algebraic type for binary trees
\question{*,@3} define an algebraic type for arithmetic expressions
\question{*,@3} define a simple interpreter for the above type

\question{*,@3} Translate the above 2 structures to an OO language. (Hint: One
class corresponds to leaves, one to branching.)

\question{*,@3} Translate the interpreter. You are not allowed to use 'instanceof'

\question{*} Translate the interpreter. You must use 'instanceof'.

\subsection{Currification and partial application}

\question{*,@3} Define a function $\mathsf{f}$ following this spec: given a
integer, return it unchanged if it is greater than zero, and zero
otherwise. (The type must be Int → Int.)

\question{*,@3} Assuming a function max : (Int × Int) → Int, define the function $\mathsf{f}$.

\question{*} Define a function max', by currifying the function max.

\question{*} Define f using max'.

\subsection{Higher-order functions}

Assume the filter, map, foldr functions as in the Haskell prelude. f
comes from the previous section.

\question{*,@3} Unfold the following expressions:
\begin{enumerate}
\item map f
\item filter ($>=$ 0)
\item foldr [] (++)
\end{enumerate}

Consider the following imperative program:
\begin{verbatim}
for (i=0;i<sizeof(a);i++)
  if (a[i].grade >= 24)
     *b++ = a[i];
\end{verbatim}
\begin{ex}{*,@3}
  How would the same algorithm be naturally expressed in a functional
  language? (Use functions from the Haskell prelude to shorten your code)
\end{ex}


\question{*} write a function that does the dot-product of two
vectors;

\question{*} make an abstract version of the above.

\question{**} Can you find the function you created in the Haskell
Data.List module?


\subsection{Closures}

Consider the program:
\begin{verbatim}
test1 xs = foldr (+) 0 xs
test2 xs = foldr (*) 1 xs
\end{verbatim}

\begin{ex}{*,@4}
  Identify higher-order applications in the above program.
\end{ex}

\begin{ex}{*,@4}
  Assuming that $\mathsf{xs}$ are lists of integers, replace the above
  uses of higher-order application by explicit closures.
  (Hint: you need to also change the definition of foldr/map).
\end{ex}

\begin{ex}{**,@4}
  Add the following line to the above program and repeat the above 2
  exercises.
\begin{verbatim}
replace a b xs = map (\x -> if x == a then b else x) xs
\end{verbatim}
\end{ex}


\question{*}
Eratosthenes' sieve is a method for finding prime numbers, dating from
ancient Greece. We start by writing down all the numbers from 2 up to
some limit, such as 1000. Then we repeatedly do the following:
\begin{itemize}
\item
The {\em first} number in the list is a prime. We generate it as an
output.
\item
We {\em remove all multiples} of the first number from the
list---including that number itself.
\item
Loop.
\end{itemize}
We terminate when no numbers remain in our list. At this point, all
prime numbers up to the limit have been found.

The algorithm can be implemented in Haskell as follows:

Write the algorithm in Haskell.

\question{*,@4}

Consider the following (totally unrelated) algorithm:
\begin{verbatim}
primes = sieve [2..1000]
sieve (n:ns) = n:sieve (filter (not . (`isDivisibleBy` n)) ns)
x `isDivisibleBy` y = x `mod` y == 0
\end{verbatim}

Inline the call of function composition in the above as a
lambda abstraction.

The only remaining higher-order function is filter.

\question{*,@4} Write a version of filter which takes an explicit
closure as an argument.  Remember to write (and use) an apply
function. Hint: in order to test your program you need to define an
example parameter, such as $(>= 0)$, etc.

\question{*} Re-write sieve using the above.

\question{**} Write a version of sieve in imperative (or OO) language,
by translation of the answer to the previous exercise. (eg. you can
not use arrays instead of lists). (Hint: write this one as a recursive program).

\subsection{Explicit state}

Consider a binary tree structure with integer values in the nodes.

\question{*,@4} In the Java version, write a function that replaces each
element with its index in preorder traversal of the tree.

\question{**,@4} Translate the function above to Haskell thinking of it
as an imperative algorithm. You should use \emph{IP} from the lecture notes.
What is the ``state of the world'' in this case?

\question{*,@4} Rewrite the Haskell version, in such a way that passing
``state of the world'' is made visible as such, that is, eliminate your
usage of \emph{IP}.


\subsection{Laziness}
There are no lazy languages that permit mutation.  \question{***, @5} Why not?

\subsubsection{Lazy Dynamic Programming}

Consider a the function computing the fibonacci sequence:
\begin{verbatim}
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
\end{verbatim}

\question{-} Estimate the time-complexity of computing $\mathsf{fib}\,n$.

One can make the above computation take linear time by saving the
intermediate results in an array:
\begin{verbatim}
fibs[0] = 0
fibs[1] = 1
for i = 2 to n do
  fibs[n] = fibs[n-1] + fibs[n-2]
\end{verbatim}

\question{*} Instead of specifying the order of filling the array via
an imperative algorithm, let Haskell's lazy evaluation take care of it.
Write the definition of the array $\mathsf{fibs}$ in Haskell.

\question{*} What portion of the array is forced when
$\mathsf{fibs}!k$ is accessed? Draw the graph of computation
dependencies for $k=5$.


\question{*, @5} Write the Floyd-Warshall algorithm in your favourite
imperative language. Assume that there is no weight on edges; and
you're only interested in whether there is a path between two given
nodes, not the number of steps in the path.

Note that the best-case performance is Cubic.

\question{*} Repeat the above, but make sure you never overwrite a
cell in a matrix. (What do you need to do to make this at all
possible?)

\question{*, @5} Using the same formula, fill the Roy-Warshall matrix
using an array comprehension in a lazy language (optionally use
explicit thunks for the contents of each cell). Discuss the best-case
performance.

\question{-} Does your favourite spreadsheet program have strict, or
lazy logical disjunction operator? Test it.

\question{-} Can you write the Roy-Warshall algorithm in it?

\question{**} Repeat the above steps with the algorithm to compute the
least edit distance. \url{http://en.wikipedia.org/wiki/Levenshtein_distance}

\begin{cplus}
int LevenshteinDistance(char s[1..m], char t[1..n])
{
  // for all i and j, d[i,j] will hold the Levenshtein distance between
  // the first i characters of s and the first j characters of t;
  // note that d has (m+1)x(n+1) values
  declare int d[0..m, 0..n]

  for i from 0 to m
    d[i, 0] := i // the distance of any first string to an empty second string
  for j from 0 to n
    d[0, j] := j // the distance of any second string to an empty first string

  for j from 1 to n
  {
    for i from 1 to m
    {
      if s[i] = t[j] then
        d[i, j] := d[i-1, j-1]       // no operation required
      else
        d[i, j] := minimum
                   (
                     d[i-1, j] + 1,  // a deletion
                     d[i, j-1] + 1,  // an insertion
                     d[i-1, j-1] + 1 // a substitution
                   )
    }
  }

  return d[m,n]
}
\end{cplus}

\subsubsection{Lazy Lists (Streams)}

Remember the sieve algorithm. Lazy lists can be (potentially)
infinite, although of course no program can evaluate {\em all} the
elements of an infinite list. Nevertheless, using lazy lists can help
us avoid building unnecessary limitations into our code.  Check that
the \verb!sieve! function also works given the {\em infinite} list
\verb![2..]!---the output should be the {\em infinite} list of all
prime numbers.


\begin{ex}{*, @5}
How would you find the first 100 prime numbers?
\end{ex}

Remark: start by answering the following questions on a simpler
algorithm, for example the function \textsf{enumFrom} which generates
the infinite list of numbers starting at a given one.

\begin{ex}{*, @5} Translate sieve to use explicit thunks (as in the lecture)
\end{ex}

Oh noes, this introduced higher-order function(s).

\begin{ex}{**}
  Where are the new higher-order functions?
\end{ex}

You know what's coming...

\question{***} Remove higher-orderness using the best technique available.
\answer{In Sieve2.hs}

\begin{ex}{**, @5}
  Write a version of lazy sieve in imperative (or OO)
language. 
\answer{Found in SieveJava directory}
\end{ex}

Since there are no more functions in the data, you can now display your
infinite lists.

\question{***} Do so for a few meaningful inputs, and interpret what
you see.


\section{Concurrent Programming}

\subsection{Channels and Processes}

\begin{ex}{*, @5}
  Write a process that manages a bank account. It has a channel for
  queries; which can be deposits and withdrawals. The answer is posted
  to a channel that comes with the query.  (Note: you cannot use
  references to store any state -- see variable-managing process for inspiration)
\end{ex}

\begin{ex}{*}
  Write a client for the above process that move ``money'' from an
  account to another. (``transaction'')
\end{ex}

\begin{ex}{*}
  Assume that withdrawals/deposits can fail. (For example if there is
  too much/litte on the account). Modify the server process
  accordingly.
\end{ex}

\begin{ex}{**, @5}
  Is the total amount of money a constant of your system? (Consider
  that transactions may fail in the ``middle''.) How can you ensure
  that it is?  Write the corresponding code.
\end{ex}

\begin{ex}{*}
  Implement a process that manages a semaphore.  The process should
  implement the requests P and V. (See the wikipedia article for
  explanation of semaphore, P and
  V). \url{http://en.wikipedia.org/wiki/Semaphore_(programming)}
\end{ex}

\begin{ex}{*}
  Implement two library functions that help communicate with the above
  server. (Hint: you may have to create channels.)
\end{ex}

\subsection{Explicit continuations}

Consider the following outline for the ``business logic'' of a
web-application:
\begin{verbatim}
session = do
   items <- webForm "What do you want to buy?"
   address <- webForm "Where do you want your stuff delivered?"
   daMoney <- webForm "Enter your credit card details, now."
   secureInDatabase daMoney (priceOf items)
   placeOrder items address
\end{verbatim}

\begin{ex}{*, @6}
  What is the purpose, and type of the webForm primitive?
\end{ex}

\begin{ex}{**, @6}
  Transform the type of webForm to take a continuation.
\end{ex}

\begin{ex}{**, @6}
  Break the above code into continuations, linked by the webForm primitive.
\end{ex}

\begin{ex}{***, @6}
  Outline what the webForm function should do. Discuss in particular
  what happens if the user presses the ``back'' button in their
  browser.
\end{ex}


\paragraph{Recursion and continuations}

Remember your interpreter for arithmetic expressions. It should have type:

% eval (Add x y) = eval x + eval y

Expr → Int

Let's make continuations explicit. In this case, the result is not
returned directly, but applied to a continuation. Hence, the type
becomes:

Expr → (Int → a) → a

\question{*, @6} Write a wrapper for the interpreter which has the above type

% wrapper expr k = k (eval expr)


\question{***, @6} Replace every recursive call in the interpreter by a
call to the wrapper.  (Hint: you must decide what is the
``continuation'' for every call, and for this you must choose an order
of evaluation!)
% eval (Add x y) = wrapper x (\a -> wrapper y (\b -> a + b))

\question{***, @6} Unfold the usage of the interpreter in the wrapper.

% wrapper (Add x y) k = k (wrapper x $ \a -> wrapper y $ \ b -> a + b)


% It would be nice to have the students find:


% eval (Add x y) k = (eval x (\a -> eval y (\b -> k (a + b))))



\section{Logic Programming}

In this section, exercises are sometimes formulated both in Prolog and Curry syntax; as indicated in the margin.
\providecommand{\Prolog}{{\tiny Prolog}}
\providecommand{\Curry}{{\tiny Curry}}
\subsection{Metavariables and unification}

\begin{ex}{*, @6}
What is the result of the following unifications?
Try to come up with the result without using the prolog/curry interpreter!

\Prolog{}
\begin{prolog}
a(X,Y) = a(b,c) 
a(X,Y) = a(Z,Z) 
a(X,X) = a(b,c) 
e(X) = a(b,b) 
d(X,X,Y) = d(Z,W,W) 
a(X,X) = d(Z,W,W) 
\end{prolog}


\Curry{}
\begin{verbatim}
data X = A X X | B | C | D X X X | E X

A x y =:= A B C  where x, y free
A x y =:= A z z  where x, y, z free
A x x =:= A B C where x free
E x =:= A B B where x free
D x x y =:= D z w w where x, y, w, z free
A x x =:= D z w w where x, y, w, z free
\end{verbatim}

\answer{
\begin{tabular}{c}
X = b, Y = c \\
X = Y = Z \\
fail \\
fail \\
X = Y = Z = W \\
\end{tabular}

}
\end{ex}

\subsubsection{Difference Lists}

A difference list is a special structure that can support efficient
concatenation. It uses unification in a clever way to that end.

The difference-list representation for a list can be obtained as follows:

\Prolog{}
\begin{prolog}
fromList([],d(X,X)).
fromList([A|As],d(A:Out,In)) :- fromList(As,d(Out,In)).
\end{prolog}


\Curry{}
\begin{verbatim}
data DList a = D [a] [a]

fromList :: [a] -> D a -> Success
fromList [] (D x x') = x =:= x'
fromList (a:as) (D (a':o) i) = a =:= a' & fromList as (D o i)
\end{verbatim}


A structure of the form \textsf{d(Out,In)} will represent the list
\textsf{L} if \textsf{Out} unifies with \textsf{L} concatenated with
\textsf{In}. Or, less technically, a list L will be represented as the
difference between Out and In: so for instance,

\Prolog{
$$[1,2] \longrightarrow d([1,2,3,4],[3,4])$$
}
\Curry{
$$[1,2] \longrightarrow D [1,2,3,4] [3,4] $$
}


You can check how fromList works by testing it:
\Prolog{
\begin{prolog}
fromList([1,2,3],X).
\end{prolog}
}
\Curry{
\begin{verbatim}
fromList [1,2,3] x where x free
\end{verbatim}
}
Note that the same metavariable (G271 in my implementation) is present twice in
the result. Note that we can get the original result back by unifying this
metavariable with the empty list.

\begin{question}{**, @6}
Write a predicate \textsf{toList :: DList a $\rightarrow$ [a] $\rightarrow$ Success} to get back to the normal list representation.

\answer{
\begin{prolog}
toList(d(X,X),[]).
toList(d(Head:Rest,Tail),[Head|OtherTail]):- toList(d(Rest,Tail),OtherTail).
\end{prolog}

toList (D x y) [] = x =:= y
toList (D (head:rest) tail) (head':otherTail) = head =:= head' & toList (D rest tail) otherTail
}

\end{question}

Given that representation for lists, it is possible to perform concatenation by
doing unification only!

\begin{ex}{**, @6}
Write a predicate dconcat to concatenate two difference lists, without
using the direct representation.

\Prolog{
\begin{prolog}
dconcat(X,Y,Z), fromList([1,2,3],X), fromList([4,5],Y), toList(Z, Final).
\end{prolog}
}

\Curry{
\begin{verbatim}
dconcat x y z & fromList [1,2,3] x & fromList [4,5] y & toList z final where x, y, z, final free
\end{verbatim}
}

should produce:

\begin{verbatim}
...
final = [1,2,3,4,5]
\end{verbatim}

\answer{
\begin{prolog}
dconcat(d(Out2,In2),d(Out1,In1),d(Out,In)) :- Out = Out2, In2 = Out1, In = In1.
\end{prolog}
or
\begin{prolog}
dconcat(d(Out,Intermediate),d(Intermediate,In),d(Out,In)).
\end{prolog}
}

\end{ex}

\begin{question}{***}
What happens when you concatenate a difference list with itself?
\answer{The difference list will contain circular, infinite lists.}
\end{question}





\subsection{Functions ↔ Relations}

Consider the following haskell function, that splits a list of
integers into two lists: one containing the positive ones (and zero),
the other containing the negative ones.
\begin{verbatim}
split [] = ([],[])
split (x:xs) | x >= 0 = (x:p,n)
             | x <  0 = (p,x:n)
  where (p,n) = split xs
\end{verbatim}

If written as a predicate, it is natural if it takes 3 arguments. For example,

\begin{verbatim}
split([3,4,-5,-1,0,4,-9],p,n)
\end{verbatim}

should bind:

\begin{verbatim}
P = [3,4,0,4]
N = [-5,-1,-9].
\end{verbatim}


\begin{question}{**}
    Write the predicate \textsf{split}. Make sure that it is \emph{reversible}. That is,
    you can recover the original list if you pass it the split lists.
\answer{
\begin{prolog}
split([],[],[]).
split([X|A],[X|P],N) :- X >= 0, split(A,P,N).
split([X|A],P,[X|N]) :- X <  0, split(A,P,N).
\end{prolog}
}
\end{question}

\begin{question}{**}
    What are the lists that are returned by \textsf{split/3} when used in reverse? Can it fail?
\answer{All the possible interleavings of the inputs. If a number of the wrong class is
in either of the inputs, it will fail.}
\end{question}

\subsection{Explicit Search}


Consider the following list comprehension, in Haskell syntax:
\begin{verbatim}
c = [f x | z <- a, y <- g z, x <- h y, p v]
\end{verbatim}

\begin{ex}{*}
  Write down possible types for f, a, g, h and p.
\end{ex}

\begin{ex}{*}
  Assume that the above functions/values (f, a, g, h and p) are
  translated to relational style. What would be natural types for
  them?
\end{ex}

\begin{ex}{*}
  Translate the list comprehension to relational style.
\end{ex}

\begin{ex}{**}
  Translate all the functions from Family.curry in the ``list of
  successes'' style, for all directions.
\end{ex}




\end{document}
