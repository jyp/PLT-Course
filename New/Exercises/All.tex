\documentclass{article}

\usepackage[utf8x]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{todonotes}
\usepackage[english]{babel}
%\usepackage{times}
\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{verbatim}
\usepackage{hyperref}

\newcommand{\percents}[1]{\protect \marginpar[l]{\bf [#1]}}
\newcounter{question}
\newcommand{\question}[1]{
  \addtocounter{question}{1}
  % {\bf Exercise~\arabic{question}} \percents{#1}
  \paragraph{Exercise~\arabic{question}  \percents{#1}}
 }
\newenvironment{ex}[1]{\question{#1}}{\paragraph{}}
\newcommand{\removed}[1]{}

\newcommand{\answer}[1]{}

% Uncomment to show answers
% \renewcommand{\answer}[1]{#1}
 

\usepackage{listings}

\lstset{language=java,basicstyle=\small}
\lstset{commentstyle=\textit,flexiblecolumns=true,mathescape=true}
\lstnewenvironment{java}
    {\lstset{language=java,frame=tb}}
    {}
\lstnewenvironment{java2}
    {\lstset{language=java}}
    {}
\lstnewenvironment{cplus}
    {\lstset{language=c++,frame=tb}}
    {}
\lstnewenvironment{cplus2}
    {\lstset{language=c++}}
    {}
\lstnewenvironment{perl}
    {\lstset{language=perl,mathescape=false,lineskip=0\baselineskip}}
    {}


\lstdefinelanguage{FSharp}
      {morekeywords={let, new, match, with, rec, open, module,
           namespace, type, of, member, and, for, in, do,  
           begin, end, fun, function, try, mutable, if, then, else, class, end},
    keywordstyle=\color{blue},
    sensitive=false,
    morecomment=[l][\color{green!50!black!80}]{///},
    morecomment=[l][\color{green!50!black!80}]{//},
    morecomment=[s][\color{green!50!black!80}]{{(*}{*)}},
    morestring=[b]",
    stringstyle=\color{red},
    columns=fullflexible
}

\lstnewenvironment{prolog}
    {\lstset{language=prolog,frame=tb}}
    {}

\begin{document}
%\listoftodos

\title{Programming Paradigms}
\author{Ramona Enache, Jean-Philippe Bernardy\footnote{with thanks to previous teams in charge of the course.}}
\maketitle


\section{Generalities}

\subsection{Paradigms, Languages, Features}
Consider the language C++ (or your favourite programming language,
...).

\question{*} Write a list of features (programming constructs)
implemented in C++. Be as exhaustive as you can (list at least 10
features).

\question{*} For each programming paradigm (Imperative, OO, etc.),
evaluate how well C++ supports that paradigm. Argue using the list
compiled in the previous answer.

\question{***} Can you identify a paradigm not studied in the course
which is supported by C++?

\subsection{Types}

\question{*} Give a meaningful type to the following values.

\begin{enumerate}
\item 4
\item 123.53
\item 1/3
\item $\pi$
\item 'c'
\item ``Hello, world!''
\item -3
\item (unary) -  
\item (binary) + 
\item sin
\item derivative
\end{enumerate}

\question{**} Explain the meaning of the following types. (Hint: what
kind of values can inhabit those types?)

\begin{enumerate}
\item String
\item String → String
\item String → String → String
\item (String → String) → String
\item String → (String → String)
\item (String → String) → (String → String)
\end{enumerate}

One can not only parameterize over values, but also over
types. (Eg. in Java, generic classes).

For example, the following type is a suitable type for a sorting
function: it expresses that the function works for any element type,
as long as you can compare its inhabitants.

∀ a. (a → a → Bool) → Array a → Array a


\question{**} Does sort in your favourite language have a similar
type? How close/far is it?

Consider the type
\[∀ a\,b. \mathsf{Pair}\,a\,b → \mathsf{Pair}\,b\,a\]
\question{***} What can possibly inhabit it?



\section{Imperative Programming}

\subsection{Gotos to loops}

Consider the algorithm:

\begin{enumerate}
\item \textbf {Preliminary:} {\it A} is an array of integers of length
  {\it n} and {\it B} is an array of integers of length {\it m}. Also
  the elements from both arrays are distinct (from the elements in
  both arrays) and in ascending order. 

\item \textbf{Step1:} if {\it n} or {\it m} is zero
  \textbf{STOP}. Otherwise if  $m\textgreater n$, set $t := \lfloor log
    \left ( m \slash n \right ) \rfloor $  and go to \textbf{Step4},
    else set $t := \lfloor log
    \left ( n \slash m \right ) \rfloor $.

\item \textbf{Step2:} compare {\it A[m]} with {\it B[n + 1 -
    $2^t$]}. If {\it A[m]} is smaller, set {\it n := n - $2^t$} and
  return to \textbf{Step1}.

\item \textbf{Step3:} using binary search(which requires exactly {\it
    t} more comparisons), insert {\it A[m]} into its proper place
  among {\it B[n + 1 -$2^t$] ... B[n]}. If {\it k} is maximal such
  that {\it B[k] \textless A[m]}, set {\it m := m - 1} and {\it n :=
    k}. Return to \textbf{Step1}.

\item \textbf{Step4:}(Step 4 and 5 are like 2 and 4, interchanging the
  roles of {\it n} and {\it m}, {\it A} and {\it B}) if {\it B[n]
    \textless A[m+1-$2^t$]}, set {\it m := m - $2^t$} and return to
  \textbf{Step1}.

\item \textbf{Step5:} insert {\it B[n]} into its proper place among
  the {\it A}s. If {\it k} is maximal such that {\it A[k] \textless
    B[n]}, set {\it m := k} and {\it n := n - 1}. Return to \textbf{Step1}.


\end{enumerate}


\question{*} 

implement binary search without gotos in the context of the
algorithm. There is a slight change compared to the classical
algorithm, since the scope of the search is different. Keep in mind! 
\todo[noline]{or} 

\question{*} 

\textbf{Step1} may require the calculation of the expression $\lfloor log
    \left ( m \slash n \right ) \rfloor $, for $n \geq m$. Explain how
    to compute this easily without division or calculation of a
    logarithm.  \todo[inline]{with gotos or explicit stack}

\question{*} 

Why does the binary search mentioned in the algorithm
always take {\it t} steps ?

\question{*} 

Explain the behaviour of the algorithm for the arrays 
{\it A} = \{87, 503, 512\} and {\it B} = \{61, 154, 170, 275, 426, 509,
  612, 653, 677, 703, 765, 897, 908\}.

\question{**} 

Implement the above-mentioned algorithm without using
{\it gotos} in a programming language of your choice. Check your
implementation with the {\it A} and {\it B} from the previous question. 

  
\subsection{Loops to gotos}
\question{*}

Translate the following \textbf{for} loop with explicit gotos:
\\
\\
{\it for (statement; condition; statement)

$\ \ \ \ $loop$\_$body}

\question{*}
Translate the do/while construct.

\question{*}
Translate the switch/case construct.

\question{*}
Translate the bubble sort algorithm.

\subsection{Pointers and call by reference}
\question{*}

Create a binary search tree where nodes contain integer number in
C/C++. Implement a function that adds a value to the tree and one that
deletes a certain value from the tree. 
\todo[inline]{maybe smth more interesting, red-black/Fibonacci tree...}


\question{*}
Write a recursive traversal of the above tree.

\question{*}
Write a swap function using call by reference.

\question{*}
Write a swap function using call by value. 

\question{**} Does Java use call by reference? Give examples to support
your answer.

\question{**} Write down pros and cons of using call by reference
vs. call by value. (Ease of use, performance, ...)

\subsection{From recursion to explicit stack}
Consider the following recursive relation for computing Fibonacci
numbers:
\\
\\
{\it $fib_{n+2} = fib_{n+1} + fib_{n}$}

\question{*}

Implement the recursive function computing the n-th Fibonacci number based on
the expression above. Why is it not efficient ?

\question{*}

Implement a slightly-optimized recursive function for the same
purpose. (Hint: use an accumulator parameter).

\question{**}

Implement a version of one of the two functions above by using an
explicit stack.  

\question{**}
Re-implement the tree traversal as above, but using explicit stacks.

\question{**}
Implement the Ackermann function without recursion.
(See \url{http://en.wikipedia.org/wiki/Ackermann_function}).


\section{Object-Oriented Programming}

Consider the following code, in C\# syntax:
\begin{java}
interface Monoid {
   Monoid op(Monoid second);
   Monoid id();
};

struct IntegerAdditiveMonoid : Monoid {
    public IntegerAdditiveMonoid(int x) { 
         elt = x;
    }    
    public IntegerAdditiveMonoid op(IntegerAdditiveMonoid second) { 
         return new IntegerAdditiveMonoid(
             elt + second.elt); 
    }
    public IntegerAdditiveMonoid id(){ 
         return new IntegerAdditiveMonoid(0);
    }
    int elt;
};

\end{java}
%

\subsection{Explicit method pointers}

\question{*} Translate the above code to a C-like language, using
explicit method pointers. (Hint: you can simply consider the interface
as a class without fields.)

\question{-} Briefly recap: what is a \textit{monoid}, mathematically?

\question{-} Give two examples of data types that can be considered monoids.
(Hint: Strings would form a monoid under the appropriate structure; what is the structure?

\question{*} Write another instance of the monoid interface, using one
of the examples you found. Also write its translation to a C-like
language.

\question{*} Assume variables \textsf{a,b} of type \textsf{Monoid}. Translate
the expression \textsf{a.op(b)}.

\question{*} Assume to objects \textsf{x,y} of two different instances
of Monoid are bound to the variables \textsf{a,b}. Explain what
happens at runtime when the expression is evaluated. (Which code is executed?)

\subsection{Co/Contra variance}

Surprise: the above code is refused by the C\# compiler:
\begin{verbatim}
> gmcs Monoids.cs 
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement 
  interface member `Monoid.op(Monoid)'
Monoids.cs(2,11): (Location of the symbol related to previous error)
Monoids.cs(6,8): error CS0535: `IntegerAdditiveMonoid' does not implement 
  interface member `Monoid.id()'
Monoids.cs(3,11): (Location of the symbol related to previous error)
Compilation failed: 2 error(s), 0 warnings
\end{verbatim}


\question{*} What if the method \textsf{op} \textit{would} compile?
Define objects \textsf{a,b}, of appropriate types, so that
\textsf{a.op(b)}, if is run, would result in a run-time error.

\question{*} What if the method \textsf{id} would compile? Could you
construct a similar run-time error? (Hint: do the translation job if
the answer is not obvious to you.)

\question{**} Explain the error messages in terms of co-/contra-/nonvariance.

\question{***} The corresponding program in Java behaves differently. Briefly
explain how, consult the Java Language Specification (JLS), and back your answer
with the appropriate clause(s) in the JLS.

\question{-} Can you change the code so that the (current)
C\#-compiler accepts it? What is the problem then?

\removed{
\subsection{Dynamic dispatching \& the visitor}

Suppose the three classes \textsf{Shape}, \textsf{Rectangle}, and 
\textsf{Circle}, and the appropriate inheritance relation between them.
Further assume a method \textsf{intersect()} that can determine whether two
shapes overlap. Obviously, the implementation of \textsf{intersect()} 
depends on the actual shapes involved. 

\question{*} Implement and design the 3 classes so that all possible
intersections of shapes can be properly handled using Smalltalk.  What
is the problem with single dispatching? Name at least 2 issues.


  The following Java snippet redesigns the
  class hierarchy using \textit{double dispatch}. 
  Explain how double dispatching works by
  giving the sequence of calls for the line marked (*) in \textsf{Main}.
  Name two problems with double dispatching.
  
\begin{java}
class Shape {
    public  boolean intersect(Shape s) {
         return s.intersectShape(this);
    }
    protected  boolean intersectShape(Shape s) {
        // intersect Shape x Shape
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // no special code for Shape x Rectangle
        return intersectShape(r);
    }
    protected  boolean intersectCircle(Circle c) {
        return intersectShape(c);
   }
}
class Rectangle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectRectangle(this);  
    }
    protected  boolean intersectRectangle(Rectangle r) {
        // Rectangle x Rectangle
        ..
    }
}
class Circle extends Shape {
    public  boolean intersect(Shape s) {
        return s.intersectCircle(this);  
    }
    protected  boolean intersectCircle(Circle c) {
        // Circle x Circle 
   }   
}

class Intersect {
   public static void Main() {
      Shape s1 = new Rectangle(); 
      Shape s2 = new Circle();
      boolean b = s2.intersect(s1);        // *
   }
}
\end{java}

The \textit{Visitor pattern} provides an alternative workaround,
also based on double dispatching. In difference
to the solution above, the pattern 
introduces two hierarchies, the visited
hierarchy and the visitor hierarchy. In the example,
 \textsf{Shape, Rectangle, Circle}
form the visited hierarchy, \textsf{IntersectVisitor} and its two
subclasses \textsf{RectangleIntersectVisitor} and \textsf{CircleIntersectVisitor}
form the visiting hierarchy. The visited classes are
augmented with a method \textsf{accept}, which uses double dispatching
to call the appropriate ShapeVisitor (and to invoke the
right computation). 

\question{*} Complete the code for the two class hierarchies and the client.
\question{*} Name two problems of the visitor approach.

\begin{java2}
class Shape {
    public void accept(IntersectVisitor v) {
	v.visitShape(this);
    }
}
class Rectangle extends Shape {
public  void accept(IntersectVisitor v) { 
        // your job
    }
}
class Circle extends Shape {
   // your job
}
 
// visitor hierarchy
abstract class IntersectVisitor { 
    boolean intersects; 
    public abstract void visitShape(Shape s);
    public abstract void visitRectangle(Rectangle r); 
    public abstract void visitCircle(Circle c); 
} 

// client code
  Shape s1 = new ..
  IntersectVisitor v = new RectangleIntersectVisitor();
  s1.accept(v);
  if (v.intersects) ...
\end{java2}
}

\section{Functional Programming}
\subsection{Algebraic Data Types and Pattern Matching}

\question{*} define an algebraic type for binary trees 
\question{*} define an algebraic type for arithmetic expressions 
\question{*} define a simple interpreter for the above type 

\question{*} Translate the above 2 structures to an OO language. (Hint: One
class corresponds to leaves, one to branching.)

\question{*} Translate the interpreter. You are not allowed to use 'instanceof'

\question{*} Translate the interpreter. You must use 'instanceof'.

\subsection{Currification and partial application}

\question{*} Define a function f following this spec.  Given a integer, return it
unchanged if it is greater than zero, and zero otherwise. (The type must be Int → Int.)

\question{*} Assuming a function max : (Int × Int) → Int, define the same function.

\question{*} Define max' by currifying the function max.

\question{*} Define f using max'.

\subsection{Higher-order functions}

Assume the filter, map, foldr functions as in the Haskell prelude. f
comes from the previous section.

\question{*} Unfold the following expressions:
\begin{enumerate}
\item map f
\item filter ($>=$ 0)
\item foldr [] (++)
\end{enumerate}

\question{*} write a function that does the dot-product of two
vectors; 

\question{*} make an abstract version of the above.

\question{**} Can you find the function you created in the Haskell
Data.List module?


\subsection{Closures}

Lazy lists can be (potentially) infinite, although of course no
program can evaluate {\em all} the elements of an infinite
list. Nevertheless, using lazy lists can help us avoid building
unnecessary limitations into our code.

Eratosthenes' sieve is a method for finding prime numbers, dating from
ancient Greece. We start by writing down all the numbers from 2 up to
some limit, such as 100. Then we repeatedly do the following:
\begin{itemize}
\item
The {\em first} number in the list is a prime. We generate it as an
output.
\item
We {\em remove all multiples} of the first number from the
list---including that number itself.
\item
Loop.
\end{itemize}
We terminate when no numbers remain in our list. At this point, all
prime numbers up to the limit have been found.

The algorithm can be implemented in Haskell as follows:

\begin{verbatim}
primes = sieve [2..1000]
sieve (n:ns) = n:sieve (filter (not . (`isDivisibleBy` n)) ns)
x `isDivisibleBy` y = x `mod` y == 0
\end{verbatim}

\question{*} Inline the call of function composition in the above.

The only remaining higher-order function is filter. 

\question{*} Write a version of filter which takes an explicit closure as an argument.

\question{*} Re-write sieve using the above.

\question{**} Write a version of sieve in imperative (or OO)
language. (You can not use arrays instead of lists).

\subsection{Explicit state}

Consider the binary tree structure written above. Assume the payload are integers.

\question{*} In the Java version, write a function that replaces each
element with its index in preorder traversal of the tree.
\question{*} Translate to Haskell.
The above can be seen as an imperative algorithm. 
\question{*} What is the ``state of the world'' in this case?

\question{*} Rewrite the Haskell version, in such a way that passing
``state of the world'' is made visible as such.


\subsection{Laziness}

\subsubsection{Lazy Dynamic Programming}

\question{*} Write the Floyd-Warshall algorithm in your favourite
imperative language. Assume that there is no weight on edges; and
you're only interested in whether there is a path between two given
nodes, not the number of steps in the path.

Note that the best-case performance is Cubic.

\question{*} Using the same formula, fill the Roy-Warshall matrix
using an array comprehension in a lazy language (optionally use
explicit thunks for the contents of each cell.)

\question{**} Discuss the best-case performance.

\question{-} Does your favourite spreadsheet program have strict, or
lazy logical disjunction operator? Test it.

\question{-} Can you write the Roy-Warshall algorithm in it?

\subsubsection{Lazy Lists (Streams)}

Remember the sieve algorithm.  Check that the \verb!sieve! function
also works given the {\em infinite} list \verb![2..]!---the output
should be the {\em infinite} list of all prime numbers.

\question{*} How would you find the first 100 prime numbers? 

Remark: start by answering the following questions on a simpler
algorithm, for example the function \textsf{enumFrom} which generates
the infinite list of numbers starting at a given one.

\question{*} Translate sieve to use explicit thunks (as in the lecture)

Oh noes, this introduced a higher-order function. 

\question{**} Where are the new higher-order functions?

You know what's coming...

\question{***} Remove higher-orderness using the best technique available.

\question{***} Write a version of lazy sieve in imperative (or OO)
language. 

Since there are no more functions in the data, you can display your
infinite lists!

\question{***} Interpret what you see.


\section{Concurrent Programming}
\subsection{Channels and Processes}

TODO

\subsection{State-carrying processes}

TODO

\subsection{Explicit continuations}

\paragraph{Removing recursion using continuations}

Remember your interpreter for arithmetic expressions. It should have type:

Expr → Int

Let's make continuations explicit. In this case, the result is not returned, but 
applied to a continuation. Hence, the type becomes:

Expr → (Int → a) → a

\question{*} Write a wapper for the interpreter which has the above type

% wrapper expr k = k (eval expr)

\question{***} Replace every recursive call in the interpreter by a call to the wrapper.
(Hint: you must choose an order of evaluation!)
% eval (Add x y) = wrapper x (\a -> wrapper y (\b -> a + b))

\question{***} Unfold the usage of the interpreter in the wrapper.

% wrapper (Add x y) k = k (w x $ \a -> w y $ \ b -> a + b)

% Also possible: (wrapper x (\a -> wrapper y (\b -> k (a + b))))
% (but does not follow the exercise)

\section{Logic Programming}
\subsection{Metavariables and unification}

\begin{ex}{*}
What is the result of the following unifications? 
Try to come up with the result without using the prolog interpreter!

\begin{tabular}{c}
a(X,Y) = a(b,c) \\
a(X,Y) = a(Z,Z) \\
a(X,X) = a(b,c) \\
a(X) = a(b,b) \\
a(X,X,Y) = a(Z,W,W) \\
\end{tabular}

\answer{

\begin{tabular}{c}
X = b, Y = c \\
X = Y = Z \\
fail \\
fail \\
X = Y = Z = W \\
\end{tabular}
    
}


\end{ex}

\subsubsection{Difference Lists}

A difference list is a special structure that can support efficient
concatenation (Recall the discussion on \texttt{append/3} predicate in
the lectures). It uses unification in a clever way to that end.

The difference-list representation for a list can be obtained as follows:

\begin{prolog}
fromList([],d(X,X)).
fromList([A|As],d(A:Out,In)) :- fromList(As,d(Out,In)).
\end{prolog}


A structure of the form \textsf{d(Out,In)} will represent the list
\textsf{L} if \textsf{Out} unifies with \textsf{L} concatenated with
\textsf{In}. Or, less technically, a list L will be represented as the
difference between Out and In: so for instance,

$$[1,2] \longrightarrow d(1:2:3:4:[],3:4:[])$$

You can check how fromList works by testing it: 
\begin{prolog}
fromList([1,2,3],X).
\end{prolog}

Note that the same metavariable (G271 in my implementation) is present twice in
the result. Note that we can get the original result back by unifying this
metavariable with the empty list.

\begin{question}{**}
Write a predicate toList/2 to get back to the normal list representation.

\answer{
\begin{prolog}
toList(d(X,X),[]).
toList(d(Head:Rest,Tail),[Head|OtherTail]):- toList(d(Rest,Tail),OtherTail).
\end{prolog}
}

\end{question}

Given that representation for lists, it is possible to perform concatenation by
doing unification only!

\begin{question}{**}
Write a predicate dconcat/3 to concatenate two difference lists, without
using the direct representation.

\begin{prolog}
dconcat(X,Y,Z), fromList([1,2,3],X), fromList([4,5],Y), toList(Z, Final).
\end{prolog}


should produce:

\begin{verbatim}
Final = [1,2,3,4,5].
\end{verbatim}

\answer{
\begin{prolog}
dconcat(d(Out2,In2),d(Out1,In1),d(Out,In)) :- Out = Out2, In2 = Out1, In = In1.
\end{prolog}

or

\begin{prolog}
dconcat(d(Out,Intermediate),d(Intermediate,In),d(Out,In)).
\end{prolog}

}


\end{question}

\end{document}
\begin{question}{***}
What happens when you concatenate a difference list with itself?
\answer{The difference list will contain circular, infinite lists.}
\end{question}







\subsection{Functions ↔ Relations}


Consider a predicate \textsf{split/3}, that splits a list of integers into two lists: one containing the positive ones (and zero), the other containing the negative ones.

\begin{verbatim}
split([3,4,-5,-1,0,4,-9],P,N)
\end{verbatim}

should return:

\begin{verbatim}
P = [3,4,0,4]
N = [-5,-1,-9].
\end{verbatim}


\begin{question}{1}
    Write the predicate \textsf{split/3}. Make sure that it is \emph{reversible}. That is,
    you can recover the original list if you pass it the split lists.
\answer{
\begin{prolog}
split([],[],[]).
split([X|A],[X|P],N) :- X >= 0, split(A,P,N).
split([X|A],P,[X|N]) :- X <  0, split(A,P,N).
\end{prolog}
}
\end{question}    

\begin{question}{1}
    What are the lists that are returned by \textsf{split/3} when used in reverse?
\answer{All the possible interleavings of the inputs. If a number of the wrong class is
in either of the inputs, it will fail.}
\end{question}


\subsection{Explicit Search}



\end{document}